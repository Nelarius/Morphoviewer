/*The MIT License (MIT)

Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

This project depends on
Delaunay.js, which is public domain
gl-matrix is under the MIT license
*/(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s=Math.PI/180;i.toRadian=function(e){return e*s};var o={};o.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},o.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},o.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},o.set=function(e,t,n){return e[0]=t,e[1]=n,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},o.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},o.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},o.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),o.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=o);var u={};u.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},u.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},u.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},u.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},u.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},u.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},u.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.rotateX=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0],s[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),s[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateY=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateZ=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),s[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),s[2]=i[2],e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),u.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=u);var a={};a.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},a.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},a.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},a.sub=a.subtract,a.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},a.mul=a.multiply,a.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},a.div=a.divide,a.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},a.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},a.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},a.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},a.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},a.dist=a.distance,a.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},a.sqrDist=a.squaredDistance,a.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},a.len=a.length,a.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},a.sqrLen=a.squaredLength,a.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},a.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},a.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},a.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},a.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),a.normalize(e,e),a.scale(e,e,t),e},a.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},a.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},a.forEach=function(){var e=a.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),a.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=a);var f={};f.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},f.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},f.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+s*a,e[1]=i*u+o*a,e[2]=r*f+s*l,e[3]=i*f+o*l,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+s*u,e[1]=i*a+o*u,e[2]=r*-u+s*a,e[3]=i*-u+o*a,e},f.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*u,e[2]=s*a,e[3]=o*a,e},f.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},f.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2))},f.LDU=function(e,t,n,r){return e[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-e[2]*n[1],[e,t,n]},typeof e!="undefined"&&(e.mat2=f);var l={};l.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},l.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+s*l,e[1]=i*f+o*l,e[2]=r*c+s*h,e[3]=i*c+o*h,e[4]=r*p+s*d+u,e[5]=i*p+o*d+a,e},l.mul=l.multiply,l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+s*f,e[1]=i*l+o*f,e[2]=r*-f+s*l,e[3]=i*-f+o*l,e[4]=u,e[5]=a,e},l.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r*f,e[1]=i*f,e[2]=s*l,e[3]=o*l,e[4]=u,e[5]=a,e},l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=r*f+s*l+u,e[5]=i*f+o*l+a,e},l.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},l.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+1)},typeof e!="undefined"&&(e.mat2d=l);var c={};c.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},c.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},c.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},c.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[3]=l-g,e[6]=h+m,e[1]=l+g,e[4]=1-f-d,e[7]=p-v,e[2]=h-m,e[5]=p+v,e[8]=1-f-c,e},c.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},c.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},c.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2))},typeof e!="undefined"&&(e.mat3=c);var h={};h.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},h.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},h.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},h.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},h.mul=h.multiply,h.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},h.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},h.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},h.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},h.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},h.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},h.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[1]=l+g,e[2]=h-m,e[3]=0,e[4]=l-g,e[5]=1-f-d,e[6]=p+v,e[7]=0,e[8]=h+m,e[9]=p-v,e[10]=1-f-c,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},h.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},h.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},h.lookAt=function(e,n,r,i){var s,o,u,a,f,l,c,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?h.identity(e):(c=m-S,p=g-x,d=y-T,v=1/Math.sqrt(c*c+p*p+d*d),c*=v,p*=v,d*=v,s=w*d-E*p,o=E*c-b*d,u=b*p-w*c,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-c*u,l=c*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=c,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(c*m+p*g+d*y),e[15]=1,e)},h.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},h.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2)+Math.pow(e[9],2)+Math.pow(e[10],2)+Math.pow(e[11],2)+Math.pow(e[12],2)+Math.pow(e[13],2)+Math.pow(e[14],2)+Math.pow(e[15],2))},typeof e!="undefined"&&(e.mat4=h);var p={};p.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.rotationTo=function(){var e=u.create(),t=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,i,s){var o=u.dot(i,s);return o<-0.999999?(u.cross(e,t,i),u.length(e)<1e-6&&u.cross(e,n,i),u.normalize(e,e),p.setAxisAngle(r,e,Math.PI),r):o>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+o,p.normalize(r,r))}}(),p.setAxes=function(){var e=c.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],p.normalize(t,p.fromMat3(t,e))}}(),p.clone=a.clone,p.fromValues=a.fromValues,p.copy=a.copy,p.set=a.set,p.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},p.add=a.add,p.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},p.mul=p.multiply,p.scale=a.scale,p.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},p.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},p.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},p.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},p.dot=a.dot,p.lerp=a.lerp,p.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},p.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},p.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},p.length=a.length,p.len=p.length,p.squaredLength=a.squaredLength,p.sqrLen=p.squaredLength,p.normalize=a.normalize,p.fromMat3=function(e,t){var n=t[0]+t[4]+t[8],r;if(n>0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[7]-t[5])*r,e[1]=(t[2]-t[6])*r,e[2]=(t[3]-t[1])*r;else{var i=0;t[4]>t[0]&&(i=1),t[8]>t[i*3+i]&&(i=2);var s=(i+1)%3,o=(i+2)%3;r=Math.sqrt(t[i*3+i]-t[s*3+s]-t[o*3+o]+1),e[i]=.5*r,r=.5/r,e[3]=(t[o*3+s]-t[s*3+o])*r,e[s]=(t[s*3+i]+t[i*3+s])*r,e[o]=(t[o*3+i]+t[i*3+o])*r}return e},p.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=p)}(t.exports)})(this);
var Delaunay;

(function() {
    "use strict";

    var EPSILON = 1.0 / 1048576.0;

    function supertriangle(vertices) {
        var xmin = Number.POSITIVE_INFINITY,
            ymin = Number.POSITIVE_INFINITY,
            xmax = Number.NEGATIVE_INFINITY,
            ymax = Number.NEGATIVE_INFINITY,
            i, dx, dy, dmax, xmid, ymid;

        for(i = vertices.length; i--; ) {
            if(vertices[i][0] < xmin) xmin = vertices[i][0];
            if(vertices[i][0] > xmax) xmax = vertices[i][0];
            if(vertices[i][1] < ymin) ymin = vertices[i][1];
            if(vertices[i][1] > ymax) ymax = vertices[i][1];
        }

        dx = xmax - xmin;
        dy = ymax - ymin;
        dmax = Math.max(dx, dy);
        xmid = xmin + dx * 0.5;
        ymid = ymin + dy * 0.5;

        return [
            [xmid - 20 * dmax, ymid -      dmax],
            [xmid            , ymid + 20 * dmax],
            [xmid + 20 * dmax, ymid -      dmax]
        ];
    }

    function circumcircle(vertices, i, j, k) {
        var x1 = vertices[i][0],
            y1 = vertices[i][1],
            x2 = vertices[j][0],
            y2 = vertices[j][1],
            x3 = vertices[k][0],
            y3 = vertices[k][1],
            fabsy1y2 = Math.abs(y1 - y2),
            fabsy2y3 = Math.abs(y2 - y3),
            xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;

        /* Check for coincident points */
        if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)
            throw new Error("Eek! Coincident points!");

        if(fabsy1y2 < EPSILON) {
            m2  = -((x3 - x2) / (y3 - y2));
            mx2 = (x2 + x3) / 2.0;
            my2 = (y2 + y3) / 2.0;
            xc  = (x2 + x1) / 2.0;
            yc  = m2 * (xc - mx2) + my2;
        }

        else if(fabsy2y3 < EPSILON) {
            m1  = -((x2 - x1) / (y2 - y1));
            mx1 = (x1 + x2) / 2.0;
            my1 = (y1 + y2) / 2.0;
            xc  = (x3 + x2) / 2.0;
            yc  = m1 * (xc - mx1) + my1;
        }

        else {
            m1  = -((x2 - x1) / (y2 - y1));
            m2  = -((x3 - x2) / (y3 - y2));
            mx1 = (x1 + x2) / 2.0;
            mx2 = (x2 + x3) / 2.0;
            my1 = (y1 + y2) / 2.0;
            my2 = (y2 + y3) / 2.0;
            xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
            yc  = (fabsy1y2 > fabsy2y3) ?
                m1 * (xc - mx1) + my1 :
                m2 * (xc - mx2) + my2;
        }

        dx = x2 - xc;
        dy = y2 - yc;
        return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};
    }

    function dedup(edges) {
        var i, j, a, b, m, n;

        for(j = edges.length; j; ) {
            b = edges[--j];
            a = edges[--j];

            for(i = j; i; ) {
                n = edges[--i];
                m = edges[--i];

                if((a === m && b === n) || (a === n && b === m)) {
                    edges.splice(j, 2);
                    edges.splice(i, 2);
                    break;
                }
            }
        }
    }

    Delaunay = {
        triangulate: function(vertices, key) {
            var n = vertices.length,
                i, j, indices, st, open, closed, edges, dx, dy, a, b, c;

            /* Bail if there aren't enough vertices to form any triangles. */
            if(n < 3)
                return [];

            /* Slice out the actual vertices from the passed objects. (Duplicate the
             * array even if we don't, though, since we need to make a supertriangle
             * later on!) */
            vertices = vertices.slice(0);

            if(key)
                for(i = n; i--; )
                    vertices[i] = vertices[i][key];

            /* Make an array of indices into the vertex array, sorted by the
             * vertices' x-position. */
            indices = new Array(n);

            for(i = n; i--; )
                indices[i] = i;

            indices.sort(function(i, j) {
                return vertices[j][0] - vertices[i][0];
            });

            /* Next, find the vertices of the supertriangle (which contains all other
             * triangles), and append them onto the end of a (copy of) the vertex
             * array. */
            st = supertriangle(vertices);
            vertices.push(st[0], st[1], st[2]);

            /* Initialize the open list (containing the supertriangle and nothing
             * else) and the closed list (which is empty since we havn't processed
             * any triangles yet). */
            open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];
            closed = [];
            edges  = [];

            /* Incrementally add each vertex to the mesh. */
            for(i = indices.length; i--; edges.length = 0) {
                c = indices[i];

                /* For each open triangle, check to see if the current point is
                 * inside it's circumcircle. If it is, remove the triangle and add
                 * it's edges to an edge list. */
                for(j = open.length; j--; ) {
                    /* If this point is to the right of this triangle's circumcircle,
                     * then this triangle should never get checked again. Remove it
                     * from the open list, add it to the closed list, and skip. */
                    dx = vertices[c][0] - open[j].x;
                    if(dx > 0.0 && dx * dx > open[j].r) {
                        closed.push(open[j]);
                        open.splice(j, 1);
                        continue;
                    }

                    /* If we're outside the circumcircle, skip this triangle. */
                    dy = vertices[c][1] - open[j].y;
                    if(dx * dx + dy * dy - open[j].r > EPSILON)
                        continue;

                    /* Remove the triangle and add it's edges to the edge list. */
                    edges.push(
                        open[j].i, open[j].j,
                        open[j].j, open[j].k,
                        open[j].k, open[j].i
                    );
                    open.splice(j, 1);
                }

                /* Remove any doubled edges. */
                dedup(edges);

                /* Add a new triangle for each edge. */
                for(j = edges.length; j; ) {
                    b = edges[--j];
                    a = edges[--j];
                    open.push(circumcircle(vertices, a, b, c));
                }
            }

            /* Copy any remaining open triangles to the closed list, and then
             * remove any triangles that share a vertex with the supertriangle,
             * building a list of triplets that represent triangles. */
            for(i = open.length; i--; )
                closed.push(open[i]);
            open.length = 0;

            for(i = closed.length; i--; )
                if(closed[i].i < n && closed[i].j < n && closed[i].k < n)
                    open.push(closed[i].i, closed[i].j, closed[i].k);

            /* Yay, we're done! */
            return open;
        },
        contains: function(tri, p) {
            /* Bounding box test first, for quick rejections. */
            if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||
                (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||
                (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||
                (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))
                return null;

            var a = tri[1][0] - tri[0][0],
                b = tri[2][0] - tri[0][0],
                c = tri[1][1] - tri[0][1],
                d = tri[2][1] - tri[0][1],
                i = a * d - b * c;

            /* Degenerate tri. */
            if(i === 0.0)
                return null;

            var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,
                v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;

            /* If we're outside the tri, fail. */
            if(u < 0.0 || v < 0.0 || (u + v) > 1.0)
                return null;

            return [u, v];
        }
    };

    if(typeof module !== "undefined")
        module.exports = Delaunay;
})();
var morphoviewer=function(c){function k(a,b){var c,d,e;c=document.getElementById(b);if(!c)return alert("mgl.getShaderFromDOM: no such shader: "+b),null;d="";for(e=c.firstChild;e;)e.nodeType==e.TEXT_NODE&&(d+=e.textContent),e=e.nextSibling;if("x-shader/x-fragment"==c.type)c=h(a,d,"fragment");else if("x-shader/x-vertex"==c.type)c=h(a,d,"vertex");else return alert("mgl.getShaderFromDOM: unknown shader type, returning null."),null;return c}function h(a,b,c){var d;if("fragment"==c)d=a.createShader(a.FRAGMENT_SHADER);
else if("vertex"==c)d=a.createShader(a.VERTEX_SHADER);else return alert("mgl.getShaderFromString: unknown shader type, returning null."),null;a.shaderSource(d,b);a.compileShader(d);return a.getShaderParameter(d,a.COMPILE_STATUS)?d:(alert("mgl.getShaderFromString: could not compile "+c+" shader: "+a.getShaderInfoLog(d)),null)}function l(a,b,c){var d=a.createProgram();a.attachShader(d,b);a.attachShader(d,c);a.linkProgram(d);a.getProgramParameter(d,a.LINK_STATUS)||console.log("mgl.getProgram: unable to link the shader program "+
a.getProgramInfoLog(d));return d}function g(a,b,c){1<c&&(c=1);return a+c*(b-a)}c.Program=function(a){this.gl=a;this.object=null};c.Program.prototype.programFromDOM=function(a,b){var c=k(this.gl,b),d=k(this.gl,a);this.object=l(this.gl,d,c)};c.Program.prototype.programFromString=function(a,b){var c=h(this.gl,a,"vertex"),d=h(this.gl,b,"fragment");this.object=l(this.gl,c,d)};c.Program.prototype.use=function(){this.gl.useProgram(this.object)};c.Program.prototype.isInUse=function(){this.gl.getIntegerv(this.gl.GL_CURRENT_PROGRAM,
0);return 0==this.object?!0:!1};c.Program.prototype.stopUsing=function(){this.isInUse()&&this.gl.useProgram(null)};c.Program.prototype.attribute=function(a){var b=this.gl.getAttribLocation(this.object,a);return-1==b?(console.log("ngl.Program.attribute: shader attribute "+a+" not found."),null):b};c.Program.prototype.uniform=function(a){var b=this.gl.getUniformLocation(this.object,a);return-1==b?(console.log("mgl.Program.uniform: shader uniform "+a+" not found."),null):b};c.Program.prototype.setUniform=
function(a,b,c){switch(c.type){case "float":this.gl.uniform1f(this.uniform(a),b);break;case "vec3":this.gl.uniform3fv(this.uniform(a),b);break;case "vec4":this.gl.uniform4fv(this.uniform(a),b);break;case "mat3":this.gl.uniformMatrix3fv(this.uniform(a),b);break;case "mat4":this.gl.uniformMatrix4fv(this.uniform(a),!1,b);break;case "int":this.gl.uniform1i(this.uniform(a),b);break;default:console.log("mgl.Program.setUniform: unknown type "+c.type)}};c.Mesh=function(a){this.gl=a;this.vno=this.vbo=null;
this.numVertices=0};c.Mesh.prototype.object=function(){return this.vbo};c.Mesh.prototype.meshFromArray=function(a,b,c,d){this.vbo=this.gl.createBuffer();this.numVertices=a.length/3;for(var e=Array(a.length),f=0;f<3*this.numVertices;f+=9)e[f]=1,e[f+1]=0,e[f+2]=0,e[f+3]=0,e[f+4]=1,e[f+5]=0,e[f+6]=0,e[f+7]=0,e[f+8]=1;a=a.concat(e);a=a.concat(b);a=a.concat(c);a=a.concat(d);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vbo);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(a),this.gl.STATIC_DRAW);
this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)};c.Mesh.prototype.vertices=function(){return this.numVertices};c.Mesh.prototype.bind=function(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vbo)};c.Mesh.prototype.unbind=function(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)};c.Camera=function(a,b,c,d){this.position=vec3.fromValues(0,0,2);this.targetPosition=vec3.fromValues(0,0,2);this.targetRadius=2;this.radius=10;this.center=vec3.fromValues(0,0,0);this.targetCenter=vec3.fromValues(0,0,0);this.polar=
Math.PI/2;this.azimuth=0;this.viewTransform=mat4.create();this.orientation=quat.fromValues(0,0,0,0);this.sensitivity=.1*this.radius;this.verticalFOV=a;this.aspectRatio=b;this.nearPlane=c;this.farPlane=d;this.viewPerspective=!1;this.targetZoomFactor=this.zoomFactor=1};c.Camera.prototype.matrix=function(){var a=mat4.create();mat4.multiply(a,this.perspective(),this.view());return a};c.Camera.prototype.viewAsOrtho=function(){this.viewPerspective=!1};c.Camera.prototype.viewAsPerspective=function(){this.viewPerspective=
!0};c.Camera.prototype.perspective=function(){return this.viewPerspective?mat4.perspective(mat4.create(),this.verticalFOV,this.aspectRatio,this.nearPlane,this.farPlane):mat4.ortho(mat4.create(),-g(this.nearPlane,this.farPlane,.01*this.aspectRatio*this.zoomFactor),g(this.nearPlane,this.farPlane,.01*this.aspectRatio*this.zoomFactor),-g(this.nearPlane,this.farPlane,.01*this.zoomFactor),g(this.nearPlane,this.farPlane,.01*this.zoomFactor),this.nearPlane,this.farPlane)};c.Camera.prototype.view=function(){return this.viewTransform};
c.Camera.prototype.getPosition=function(){return vec3.fromValues(-this.position[0],-this.position[1],-this.position[2])};c.Camera.prototype.setFOV=function(a){if(0>a)throw"mgl.Camera.setFOV: negative vertical field of view";this.verticalFOV=a};c.Camera.prototype.setAspectRatio=function(a){if(0>a)throw"mgl.Camera.setAspectRatio: negative aspect ratio";this.aspectRatio=a};c.Camera.prototype.setNearPlane=function(a){if(a>this.farPlane)throw"mgl.Camera.setNearPlane: near plane is farther than the far plane";
this.nearPlane=a};c.Camera.prototype.setFarPlane=function(a){if(a<this.nearPlane)throw"mgl.Camera.setFarPlane: far plane is nearer than the near plane";this.farPlane=a};c.Camera.prototype.pan=function(a,b){deltaX=vec3.scale(vec3.create(),this.right(),this.sensitivity*a);vec3.add(this.targetCenter,this.targetCenter,deltaX);deltaY=vec3.scale(vec3.create(),this.up(),this.sensitivity*b);vec3.add(this.targetCenter,this.targetCenter,deltaY)};c.Camera.prototype.dolly=function(a){this.targetRadius+=this.sensitivity*
a;0>this.targetRadius&&(this.targetRadius=.001)};c.Camera.prototype.orbit=function(a,b){var c=this.polar-=b,d=Math.PI;.01>c?c=.01:c>d&&(c=d);this.polar=c;this.azimuth-=a};c.Camera.prototype.update=function(a){this.targetZoomFactor=.07*this.targetRadius;this.zoomFactor=g(this.zoomFactor,this.targetZoomFactor,20*a);this.radius=g(this.radius,this.targetRadius,20*a);vec3.lerp(this.center,this.center,this.targetCenter,20*a);this.sensitivity=.1*this.radius;var b=vec3.fromValues(Math.sin(this.polar)*Math.sin(this.azimuth),
Math.cos(this.polar),Math.sin(this.polar)*Math.cos(this.azimuth));this.targetPosition=vec3.add(vec3.create(),this.center,vec3.scale(vec3.create(),b,this.radius));vec3.lerp(this.position,this.position,this.targetPosition,20*a);a=vec3.cross(vec3.create(),b,vec3.fromValues(0,1,0));vec3.normalize(a,a);b=vec3.cross(vec3.create(),a,b);mat4.lookAt(this.viewTransform,this.position,this.center,b);quat.fromMat3(this.orientation,mat3.fromMat4(mat3.create(),this.viewTransform))};c.Camera.prototype.setBestPositionForModel=
function(a){var b=Math.max(Math.abs(a.max.y),Math.abs(a.min.y));a=Math.max(Math.abs(a.max.x),Math.abs(a.min.x));this.targetRadius=1.1*Math.max(b,a)/Math.tan(.5*this.verticalFOV)};c.Camera.prototype.forward=function(){var a=mat4.create();mat4.fromQuat(a,this.orientation);mat4.invert(a,a);var b=vec4.fromValues(0,0,-1,1);vec4.transformMat4(b,b,a);return vec3.fromValues(b[0],b[1],b[2])};c.Camera.prototype.right=function(){var a=mat4.fromQuat(mat4.create(),this.orientation);mat4.invert(a,a);var b=vec4.fromValues(1,
0,0,1);vec4.transformMat4(b,b,a);return vec3.fromValues(b[0],b[1],b[2])};c.Camera.prototype.up=function(){var a=mat4.create();mat4.fromQuat(a,this.orientation);mat4.invert(a,a);var b=vec4.fromValues(0,1,0,1);vec4.transformMat4(b,b,a);return vec3.fromValues(b[0],b[1],b[2])};c.Camera.prototype.positionLeft=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=Math.PI/2;this.azimuth=Math.PI/2};c.Camera.prototype.positionRight=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=Math.PI/
2;this.azimuth=3*Math.PI/2};c.Camera.prototype.positionTop=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=.001;this.azimuth=0};c.Camera.prototype.positionBottom=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=Math.PI;this.azimuth=0};c.Camera.prototype.positionFront=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=Math.PI/2;this.azimuth=0};c.Camera.prototype.positionBack=function(){this.targetCenter=vec3.fromValues(0,0,0);this.polar=Math.PI/2;this.azimuth=
Math.PI};c.directional={materialShininess:40,materialSurfaceColor:vec3.fromValues(.6,.6,.6),materialSpecularColor:vec3.fromValues(.9,.9,.9),lightDirection:vec3.fromValues(1,0,-1),lightHalfVector:vec3.fromValues(0,0,-1),lightIntensities:vec3.fromValues(1,1,.9),lightAmbientCoefficient:.1,camera:mat4.create(),model:mat4.create(),cameraPosition:vec3.fromValues(0,0,-1),enableAttributes:function(a,b){a.enableVertexAttribArray(b.attribute("vert"));a.enableVertexAttribArray(b.attribute("normal"))},setAttributes:function(a,
b,c){a.vertexAttribPointer(b.attribute("vert"),3,a.FLOAT,!1,0,0);a.vertexAttribPointer(b.attribute("normal"),3,a.FLOAT,!1,0,24*c)},setUniforms:function(a){a.setUniform("material.shininess",this.materialShininess,{type:"float"});a.setUniform("material.surfaceColor",this.materialSurfaceColor,{type:"vec3"});a.setUniform("material.specularColor",this.materialSpecularColor,{type:"vec3"});var b=vec3.create();vec3.normalize(b,this.lightDirection);a.setUniform("light.direction",b,{type:"vec3"});b=vec3.create();
vec3.normalize(b,this.lightHalfVector);a.setUniform("light.halfVector",b,{type:"vec3"});a.setUniform("light.intensities",this.lightIntensities,{type:"vec3"});a.setUniform("light.ambientCoefficient",this.lightAmbientCoefficient,{type:"float"});b=mat4.create();mat4.invert(b,this.model);mat4.transpose(b,b);a.setUniform("camera",this.camera,{type:"mat4"});a.setUniform("normalMatrix",b,{type:"mat4"});a.setUniform("model",this.model,{type:"mat4"});a.setUniform("cameraPosition",this.cameraPosition,{type:"vec3"})},
vertex:"uniform mat4 model;\nuniform mat4 normalMatrix;\nuniform mat4 camera;\nuniform mediump vec3 cameraPosition;\nattribute vec3 vert;\nattribute vec3 normal;\nvarying mediump vec3 surfToCamera;\nvarying mediump vec3 fragPos;\nvarying mediump vec3 fragNormal;\nvoid main( void ) {\n\t//just pass this value through for interpolation\n\tfragNormal = vec3( normalMatrix * vec4( normal, 0.0 ) );\n\tfragPos = vec3( model * vec4( vert, 1.0 ) );\n\tsurfToCamera = normalize( vec3( cameraPosition - fragPos ) );\n\tgl_Position = camera * model * vec4( vert, 1.0 );\n}",
fragment:"struct Material {\n\tmediump float shininess;\n\tmediump vec3 surfaceColor;\n\tmediump vec3 specularColor;\n};\nstruct DirectionalLight {\n\tmediump vec3 direction;\t//this needs to be normalized\n\tmediump vec3 halfVector;\n\tmediump vec3 intensities;\n\tmediump float ambientCoefficient;\n};\nuniform Material material;\nuniform DirectionalLight light;\nvarying mediump vec3 surfToCamera;\nvarying mediump vec3 fragPos;\nvarying mediump vec3 fragNormal;\nvoid main( void ) {\n\t//ambient\n\tmediump vec3 ambient = light.ambientCoefficient * material.surfaceColor * light.intensities;\n\t//diffuse\n\tmediump float diffuseCoefficient =  max( 0.0, dot( fragNormal, light.direction ) );\n\tmediump vec3 diffuse = diffuseCoefficient * material.surfaceColor * light.intensities;\n\t//specular\n\tmediump float specularCoefficient = 0.0;\n\tif ( diffuseCoefficient > 0.0 ) {\n\t\tmediump vec3 reflection = normalize( reflect( light.halfVector, fragNormal ) );\n\t\tspecularCoefficient = pow( max( 0.0, dot( surfToCamera, reflection ) ), material.shininess );\n\t}\n\tmediump vec3 specular = specularCoefficient * material.specularColor;\n\tmediump vec3 linearColor = ambient + diffuse + specular;\n\tmediump vec3 gamma = vec3( 1.0 / 2.2 );\n\tgl_FragColor = vec4( pow( linearColor, gamma ), 1.0 );\n}"};
c.color={camera:mat4.create(),model:mat4.create(),colorMode:1,enableAttributes:function(a,b){a.enableVertexAttribArray(b.attribute("vert"));a.enableVertexAttribArray(b.attribute("curvature"));a.enableVertexAttribArray(b.attribute("orientation"))},setAttributes:function(a,b,c){a.vertexAttribPointer(b.attribute("vert"),3,a.FLOAT,!1,0,0);a.vertexAttribPointer(b.attribute("curvature"),1,a.FLOAT,!1,0,36*c);a.vertexAttribPointer(b.attribute("orientation"),1,a.FLOAT,!1,0,40*c)},setUniforms:function(a){a.setUniform("camera",
this.camera,{type:"mat4"});a.setUniform("model",this.model,{type:"mat4"});a.setUniform("colorMode",this.colorMode,{type:"int"})},vertex:"precision mediump float;\nattribute vec3 vert;\nattribute float curvature;\nattribute float orientation;\nuniform mat4 model;\nuniform mat4 camera;\nuniform int colorMode;\nvarying vec4 fragColor;\nvec4 rainbowColor( float scalar );\nvoid main() {\n\tif ( colorMode == 1 ) {\t//dirichlet normal energy\n\t\tfragColor = rainbowColor( curvature );\n\t} else if ( colorMode == 2 ) {\t//orientation map\n\t\tfragColor = rainbowColor( orientation );\n\t}\n\tgl_Position = camera * model * vec4( vert, 1.0 );\n}\nvec4 rainbowColor( float scalar ) {\t//scalar must be normalized!\n\tvec3 color = vec3( 0.0, 0.0, 0.0 );\n\t//if ( scalar >= 0.0 && scalar < 0.2 ) {\n\t//\tcolor.r = 5.0 * scalar;\n\t//\tcolor.b = 1.0;\n\tif ( scalar >= 0.0 && scalar < 0.25 ) {\n\t\tcolor.g = scalar * 4.0;\t//green varies linearly between [0,1]\n\t\tcolor.b = 1.0;\t\t\t//blue is maxed out\n\t} else if ( scalar >= 0.25 && scalar < 0.35 ) {\n\t\tcolor.g = 1.0;\t\t\t//green is maxed out\n\t\tcolor.b = 1.0 - 10.0 * ( scalar - 0.25 );\t//blue varies between [1,0]\n\t} else if ( scalar >= 0.35 && scalar < 0.75 ) {\n\t\tcolor.r = ( scalar - 0.35 ) * 2.5;\t//red varies between [0,1]\n\t\tcolor.g = 1.0;\t\t\t\t\t//green is maxed out\n\t} else if ( scalar >= 0.75 && scalar <= 1.0 ) {\n\t\tcolor.r = 1.0;\t//red is maxed out\n\t\tcolor.g = 1.0 - 4.0 * ( scalar - 0.75 );\t//green varies between [1,0]\n\t}\n\treturn vec4( color, 1.0 );\n}\n",
fragment:"precision mediump float;\nvarying vec4 fragColor;\nvoid main() {\n\tgl_FragColor = fragColor;\n}\n"};c.wireframe={camera:mat4.create(),model:mat4.create(),surfaceColor:vec3.fromValues(.6,.6,.6),enableAttributes:function(a,b){a.enableVertexAttribArray(b.attribute("vert"));a.enableVertexAttribArray(b.attribute("barycentric"))},setAttributes:function(a,b,c){a.vertexAttribPointer(b.attribute("vert"),3,a.FLOAT,!1,0,0);a.vertexAttribPointer(b.attribute("barycentric"),3,a.FLOAT,!1,0,12*c)},setUniforms:function(a){a.setUniform("camera",
this.camera,{type:"mat4"});a.setUniform("model",this.model,{type:"mat4"});a.setUniform("surfaceColor",this.surfaceColor,{type:"vec3"})},vertex:"attribute vec3 vert;\nattribute vec3 barycentric;\nuniform mat4 camera;\nuniform mat4 model;\nvarying mediump vec3 barycentricPos;\nvoid main( void ) {\n\tbarycentricPos = barycentric;\n\tgl_Position = camera * model * vec4( vert, 1.0 );\n}",fragment:"uniform mediump vec3 surfaceColor;\nvarying mediump vec3 barycentricPos;\nvoid main( void ) {\n\tif ( any( lessThan( barycentricPos, vec3( 0.02 ) ) ) ) {\n\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( surfaceColor, 1.0 );\n\t}\n}"};
c.hemisphere={camera:mat4.create(),model:mat4.create(),normalMatrix:mat4.create(),skyColor:vec3.fromValues(.83,.819,.819),groundColor:vec3.fromValues(.181,.161,.095),polar:0,azimuth:0,enableAttributes:function(a,b){a.enableVertexAttribArray(b.attribute("vert"));a.enableVertexAttribArray(b.attribute("norm"))},setAttributes:function(a,b,c){a.vertexAttribPointer(b.attribute("vert"),3,a.FLOAT,!1,0,0);a.vertexAttribPointer(b.attribute("norm"),3,a.FLOAT,!1,0,24*c)},setUniforms:function(a){var b=vec3.fromValues(Math.sin(this.polar)*
Math.sin(this.azimuth),Math.cos(this.polar),Math.sin(this.polar)*Math.cos(this.azimuth));a.setUniform("lightPosition",b,{type:"vec3"});a.setUniform("skyColor",this.skyColor,{type:"vec3"});a.setUniform("groundColor",this.groundColor,{type:"vec3"});b=mat4.create();mat4.invert(b,this.model);mat4.transpose(b,b);a.setUniform("normalMatrix",b,{type:"mat4"});a.setUniform("camera",this.camera,{type:"mat4"});a.setUniform("model",this.model,{type:"mat4"})},vertex:"precision mediump float;\nattribute vec3 vert;\nattribute vec3 norm;\nuniform mat4 camera;\nuniform mat4 model;\nuniform mat4 normalMatrix;\nuniform vec3 lightPosition;\nuniform vec3 skyColor;\nuniform vec3 groundColor;\nvarying vec3 fragColor;\nvoid main() {\n\tvec3 fragNormal = vec3( normalMatrix * vec4( norm, 0.0 ) );\n\tvec3 position = vec3( model * vec4( vert, 1.0 ) );\n\tvec3 lightVector = normalize( lightPosition - normalize( position ) );\n\tfloat theta = dot( fragNormal, lightVector );\n\tfloat a = theta * 0.5 + 0.5;\n\tfragColor = mix( groundColor, skyColor, a );\n\tgl_Position = camera * model * vec4( vert, 1.0 );\n}",
fragment:"precision mediump float;\nvarying vec3 fragColor;\nvoid main() {\n\tgl_FragColor = vec4(fragColor, 1.0 );\n}"};return c}(morphoviewer||{});
var morphoviewer=function(n){function r(c,e){var g=new XMLHttpRequest;g.open("GET",c,!0);g.responseType="arraybuffer";g.onload=function(c){e(c.target.response)};g.send()}function u(c,e){for(var g="";10!=c[e];)g+=String.fromCharCode(c[e++]);return g}function v(c){for(var e=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY,d=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,f=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,k=0;k<c.length;k++)c[k][0]<e&&(e=c[k][0]),c[k][0]>g&&(g=c[k][0]),c[k][1]<
d&&(d=c[k][1]),c[k][1]>h&&(h=c[k][1]),c[k][2]<f&&(f=c[k][2]),c[k][2]>l&&(l=c[k][2]);c=g-e;h-=d;l-=f;e+=.5*c;d+=.5*h;f+=.5*l;c=Math.max(c,h,l);return[[e-10*c,d-c,f-10*c],[e,d+10*c,f],[e+10*c,d-c,f+10*c]]}function w(c,e,g,d){var h=[c[e][0]-c[g][0],c[e][1]-c[g][1],c[e][2]-c[g][2]],f=[c[d][0]-c[e][0],c[d][1]-c[e][1],c[d][2]-c[e][2]],l=[h[1]*f[2]-h[2]*f[1],h[2]*f[0]-h[0]*f[2],h[0]*f[1]-h[1]*f[0]];vec3.cross(l,h,f);g=[c[g][0]+.5*h[0],c[g][1]+.5*h[1],c[g][2]+.5*h[2]];d=[c[e][0]+.5*f[0],c[e][1]+.5*f[1],c[e][2]+
.5*f[2]];h=[l[1]*h[2]-l[2]*h[1],l[2]*h[0]-l[0]*h[2],l[0]*h[1]-l[1]*h[0]];l=[l[1]*f[2]-l[2]*f[1],l[2]*f[0]-l[0]*f[2],l[0]*f[1]-l[1]*f[0]];f=mat2.create();f[0]=h[0];f[1]=-l[0];f[2]=h[1];f[3]=-l[1];d=vec2.fromValues(d[0]-g[0],d[1]-g[1]);mat2.invert(f,f);d=f[0]*d[0]+f[1]*d[1];g=[g[0]+d*h[0],g[1]+d*h[1],g[2]+d*h[2]];return{center:g,radiusSquared:(c[e][0]-g[0])*(c[e][0]-g[0])+(c[e][1]-g[1])*(c[e][1]-g[1])+(c[e][2]-g[2])*(c[e][2]-g[2])}}function z(c,e){var g=[e[0]-c.center[0],e[1]-c.center[1],e[2]-c.center[2]];
return c.radiusSquared-(g[0]*g[0]+g[1]*g[1]+g[2]*g[2])>A}function B(c){for(var e=c.length-2;-1<e;e--)for(var g=0;g<e;g++)if(a=c[e][0],b=c[e][1],x=c[g][0],y=c[g][1],a===x&&b===y||a===y&&b===x)c.splice(g,1),c.splice(e,1)}var A=1/1048576;n.vertexArrayFromOBJ=function(c,e){r(c,function(c){var d={vertices:{v:[],i:[]},normals:{v:[],i:[]}},h=0;for(c=new Uint8Array(c);h<c.length;){var f=u(c,h),h=h+(f.length+1),f=f.replace(/ +(?= )/g,""),f=f.replace(/(^\s+|\s+$)/g,""),f=f.split(" ");"v"==f[0]&&d.vertices.v.push([parseFloat(f[1]),
parseFloat(f[2]),parseFloat(f[3])]);"vn"==f[0]&&d.normals.v.push([parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])]);if("f"==f[0]){var l=d.vertices.v.length,k=d.normals.v.length,m=f[1].split("/");if(1==m.length){m=parseInt(m)-1;0>m&&(m=l+m+1);for(var q=2;q<f.length-1;q++){var p=parseInt(f[q])-1,n=parseInt(f[q+1])-1;0>p&&(p=l+p+1,n=l+n+1);d.vertices.i.push([m,p,n]);0<d.normals.v.length&&d.normals.i.push([m,p,n])}}else{var s=parseInt(m[0])-1,m=parseInt(m[2])-1;0>s&&(s=l+s+1);0>m&&(m=k+m+1);for(q=
2;q<f.length-1;q++){var p=f[q].split("/"),n=f[q+1].split("/"),t=parseInt(p[0])-1,r=parseInt(n[0])-1,p=parseInt(p[2])-1,n=parseInt(n[2])-1;0>t&&(t=l+t+1,r=l+r+1);0>p&&(p=k+p+1,n=k+n+1);d.vertices.push([s,t,r]);d.normals.push([m,p,n])}}}}void 0!=e&&e(d)})};n.vertexArrayFromPointCloud=function(c,e,g){"undefined"===typeof g&&(g=",");r(c,function(c){var h=g,f=[];c=new Uint8Array(c);for(var l=0;l<c.length;){var k=u(c,l),l=l+(k.length+1),k=k.split(h);f.push([parseFloat(k[0]),parseFloat(k[1]),parseFloat(k[2])])}void 0!=
e&&e(f)})};n.vertexArrayFromTOOTH=function(c,e){r(c,function(c){var d={vertices:{v:[],i:[]},normals:[],curvature:[],orientation:[]},h=0;for(c=new Uint8Array(c);h<c.length;){var f=u(c,h),h=h+(f.length+1),f=f.split(" ");"vertex"==f[0]?d.vertices.v.push([parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])]):"normal"==f[0]?(d.normals.push(f[1]),d.normals.push(f[2]),d.normals.push(f[3])):"triangle"==f[0]?d.vertices.i.push([parseInt(f[1])-1,parseInt(f[2])-1,parseInt(f[3])-1]):"curvature"==f[0]?(d.curvature.push(f[1]),
d.curvature.push(f[1]),d.curvature.push(f[1])):"orientation"==f[0]&&d.orientation.push(f[1])}void 0!=e&&e(d)})};n.centerPointCloud=function(c){for(var e,g=e=0,d=0,h=0;h<c.length;h++)e+=c[h][0],g+=c[h][1],d+=c[h][2];e/=c.length;g/=c.length;d/=c.length;e=[e,g,d];for(g=0;g<c.length;g++)c[g][0]-=e[0],c[g][1]-=e[1],c[g][2]-=e[2]};n.unwrapArray=function(c,e){for(var g=[],d=0;d<e.length;d++){if(e[d][0]>=c.length||e[d][1]>=c.length||e[d][2]>=c.length)throw console.log(e[d][0]+" "+e[d][1]+" "+e[d][2]+", length: "+
c.length),"MESH FAILURE";g.push(c[e[d][0]][0],c[e[d][0]][1],c[e[d][0]][2]);g.push(c[e[d][1]][0],c[e[d][1]][1],c[e[d][1]][2]);g.push(c[e[d][2]][0],c[e[d][2]][1],c[e[d][2]][2])}return g};n.getAabb=function(c){for(var e=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY,d=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,f=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,k=0;k<c.length;k++)c[k][0]<e&&(e=c[k][0]),c[k][0]>g&&(g=c[k][0]),c[k][1]<d&&(d=c[k][1]),c[k][1]>h&&(h=c[k][1]),c[k][2]<f&&(f=
c[k][2]),c[k][2]>l&&(l=c[k][2]);return{min:{x:e,y:d,z:f},max:{x:g,y:h,z:l},center:{x:e+g/2,y:d+h/2,z:f+l/2}}};n.triangulate=function(c){c=Delaunay.triangulate(c);for(var e=[],g=0;g<c.length;g+=3)e.push([c[g],c[g+1],c[g+2]]);return e};n.delaunay=function(c){var e=c.length;if(3>e)return[];var g=[],d=[];c.sort(function(c,d){return c[0]-d[0]});var h=v(c);c.push(h[0],h[1],h[2]);g.push([e,e+1,e+2]);for(h=e-1;-1<h;h--){for(var f=[],l=c[h],k=g.length-1;-1<k;k-=1){var m=w(c,g[k][0],g[k][1],g[k][2]);z(m,l)?
(f.push([g[k][0],g[k][1]],[g[k][1],g[k][2]],[g[k][2],g[k][0]]),g.splice(k,1)):0<m.center[0]-l[0]&&(d.push(g[k].slice(0)),g.splice(k,1))}B(f);for(k=0;k<f.length;k++)g.push([f[k][0],f[k][1],h])}for(h=0;h<g.length;h++)d.push(g[h].slice(0));g=[];for(h=d.length-1;-1<h;h-=1)d[h][0]<e&&d[h][1]<e&&d[h][2]<e&&g.push(d[h].slice(0));c.splice(e,3);return g};n.faceNormals=function(c,e){for(var g=Array(c.length),d=0;d<e.length;d++){var h=vec3.fromValues(c[e[d][1]][0]-c[e[d][0]][0],c[e[d][1]][1]-c[e[d][0]][1],c[e[d][1]][2]-
c[e[d][0]][2]),f=vec3.fromValues(c[e[d][2]][0]-c[e[d][0]][0],c[e[d][2]][1]-c[e[d][0]][1],c[e[d][2]][2]-c[e[d][0]][2]),h=vec3.cross(vec3.create(),h,f);vec3.normalize(h,h);g[e[d][0]]=[h[0],h[1],h[2]];g[e[d][1]]=[h[0],h[1],h[2]];g[e[d][2]]=[h[0],h[1],h[2]]}return g};n.vertexNormals=function(c,e){for(var g=Array(c.length),d=0;d<c.length;d++)g[d]=[];for(d=0;d<e.length;d++)g[e[d][0]].push(e[d][1],e[d][2]),g[e[d][1]].push(e[d][0],e[d][2]),g[e[d][2]].push(e[d][0],e[d][1]);for(var h=Array(c.length),d=0;d<
e.length;d++){var f=vec3.fromValues(c[e[d][1]][0]-c[e[d][0]][0],c[e[d][1]][1]-c[e[d][0]][1],c[e[d][1]][2]-c[e[d][0]][2]),l=vec3.fromValues(c[e[d][2]][0]-c[e[d][0]][0],c[e[d][2]][1]-c[e[d][0]][1],c[e[d][2]][2]-c[e[d][0]][2]),f=vec3.cross(vec3.create(),f,l);h[e[d][0]]=[f[0],f[1],f[2]];h[e[d][1]]=[f[0],f[1],f[2]];h[e[d][2]]=[f[0],f[1],f[2]]}f=Array(c.length);for(d=0;d<c.length;d++){for(var l=vec3.fromValues(0,0,0),k=0;k<g[d].length;k++)vec3.add(l,l,vec3.fromValues(h[g[d][k]][0],h[g[d][k]][1],h[g[d][k]][2]));
vec3.normalize(l,l);f[d]=Array(3);f[d][0]=l[0];f[d][1]=l[1];f[d][2]=l[2]}return f};n.surfaceVariation=function(c,e){for(var g=Number.NEGATIVE_INFINITY,d=Number.POSITIVE_INFINITY,h=[],f=0;f<c.length;f+=9){var l=vec3.fromValues(c[f+3]-c[f],c[f+4]-c[f+1],c[f+5]-c[f+2]),k=vec3.fromValues(c[f+6]-c[f],c[f+7]-c[f+1],c[f+8]-c[f+2]),m=mat2.create();m[0]=vec3.dot(l,l);m[1]=vec3.dot(l,k);m[2]=vec3.dot(l,k);m[3]=vec3.dot(k,k);var k=vec3.fromValues(e[f+3]-e[f],e[f+4]-e[f+1],e[f+5]-e[f+2]),n=vec3.fromValues(e[f+
6]-e[f],e[f+7]-e[f+1],e[f+8]-e[f+2]),l=mat2.create();l[0]=vec3.dot(k,k);l[1]=vec3.dot(k,n);l[2]=vec3.dot(k,n);l[3]=vec3.dot(n,n);k=mat2.create();mat2.invert(m,m);mat2.multiply(k,m,l);m=k[0]+k[3];1E3<m&&(m=1E3);h.push(m);h.push(m);h.push(m);m>g?g=m:m<d&&(d=m)}for(f=0;f<h.length;f++)h[f]/=g,h[f]=1-Math.exp(2.99572315-15*h[f])/20;return h};n.surfaceOrientation=function(c){for(var e=[],g=0;g<c.length;g+=3){var d=vec2.normalize(vec2.create(),vec2.fromValues(c[g],c[g+1]));d=Math.atan2(d[1],d[0]);d=d>2*
Math.PI?d-2*Math.PI:0>d?d+2*Math.PI:d;d=Math.floor(d/(2*Math.PI/8));d/=7;e.push(d)}return e};return n}(morphoviewer||{});

/*
Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/

/**
 * @namespace The morphoviewer namespace contains functions for viewing and manipulating
 * morphological data from voxel data files, or point cloud data files.
 */

var morphoviewer = ( function( tools ) {

    //public interface goes here
    var module = {};

    var gl;

    var fps = 40.0;
    var camera;
    var modelView = mat4.create();	//identity matrix, models centered at (0, 0, 0)
    var mesh;

    var renderFunctor = function() {};	//do nothing initially

    var wireframeProgram;	//the wireframe shader program
    var illuminationProgram;//the illumination shader program
    var colorProgram;		//the surface curvature shader program
    var currentProgram;

    var timer;

    var mouse = { prevX: 0, prevY: 0,
        dx: 0, dy: 0 };

    /**
     * Initialize the morphoviewer.
     *
     * @param {String} canvasId the DOM id of the HTML5 canvas. If the parameter is not
     * supplied, the "glcanvas" id will be searched for.
     */
    module.initialize = function( canvasId ) {
        if ( canvasId == undefined ) {
            cid = "glcanvas";
        } else {
            cid = canvasId;
        }
        //declared globally for later use
        canvas = document.getElementById( cid );

        //Event handlers for input
        canvas.onmousedown = onMouseDown;
        canvas.onmouseup = onMouseUp;
        canvas.oncontextmenu = function( e ) { e.preventDefault(); };
        //add mouse wheel listener to the page (not the canvas!)
        //some compatibility cruft
        var mousewheelEvent = (/FireFox/i.test(navigator.userAgent))?"DOMMouseScroll" : "mousewheel";
        if ( document.attachEvent ) {	//if IE
            document.attachEvent( "on"+mousewheelEvent, onMouseWheel );
        } else if ( document.addEventListener ) {	//WC3 browsers
            document.addEventListener( mousewheelEvent, onMouseWheel, false );
        }

        gl = initWebGL( canvas );

        //continue only if WebGL is available and working
        if ( gl ) {
            gl.clearColor( 0.10, 0.16, 0.16, 1.0 );
            gl.enable( gl.DEPTH_TEST );
            gl.depthFunc( gl.LEQUAL );
            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

            setInterval( drawScene, 1000.0 / fps );
        } else {
            alert( "morphoviewer.initialize: Unable to initialize WebGL. Your browser may not support it." );
        }

        timer = new Date();

        //the morphoviewer has only one camera
        var aspectRatio = canvas.clientWidth / canvas.clientHeight;
        camera = new tools.Camera( Math.PI * 67.0 / 180.0, aspectRatio, 0.01, 1000.0 );

        initShaders();
    };

    function initWebGL( canvas ) {
        var context = null;
        try {
            context = canvas.getContext( "webgl" ) || canvas.getContext( "experimental-webgl" );
        } catch( e ) {
            //
        }

        return context;
    }

    function initShaders() {
        wireframeProgram = new tools.Program( gl );
        wireframeProgram.programFromString( tools.wireframe.vertex, tools.wireframe.fragment );

        colorProgram = new tools.Program( gl );
        colorProgram.programFromString( tools.color.vertex, tools.color.fragment );

        illuminationProgram = new tools.Program( gl );
        illuminationProgram.programFromString( tools.directional.vertex, tools.directional.fragment );

        hemisphereProgram = new tools.Program( gl );
        hemisphereProgram.programFromString( tools.hemisphere.vertex, tools.hemisphere.fragment );
    }

    function onMouseWheel( e ) {
        var event = window.event || e;
        var delta = event.detail ? event.detail * (-120) : event.wheelDelta;
        camera.dolly( delta * -0.0025 );
    }

    function onMouseDown( event ) {
        if ( !event.which && event.button ) {
            if ( event.button & 1 ) {		//Left
                event.which = 1;
            } else if ( event.button & 4 ) {//Middle
                event.which = 2;
            } else if ( event.button & 2 ) {//Right
                event.which = 3;
            }
        }
        /*Update mouse coordinates so that we don't create
         * a huge delta in the opposite direction*/
        mouse.prevX = event.pageX;
        mouse.prevY = event.pageY;
        switch ( event.which ) {
            case 1:
                canvas.onmousemove = function( e ) {
                    onMouseMove( e );
                    camera.orbit( mouse.dx * 0.004, mouse.dy * 0.004 );
                };
                break;
            case 3:
                canvas.onmousemove = function( e ) {
                    onMouseMove( e );
                    camera.pan( mouse.dx * -0.01, mouse.dy * 0.01 );
                };
                break;
        }
    }

    function onMouseUp( event ) {
        canvas.onmousemove = function( e ) {return false;};
    }

    function onMouseMove( event ) {
        var x = event.pageX;
        var y = event.pageY;
        mouse.dx = x - mouse.prevX;
        mouse.dy = y - mouse.prevY;
        mouse.prevX = x;
        mouse.prevY = y;
    }

    function drawScene() {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        var endTime = new Date();
        var deltaTime = endTime - timer;
        deltaTime /= 1000.0;

        camera.update( deltaTime );

        renderFunctor();

        timer = new Date();
    }

    /**
     * View a 3d file. The file can be a csv point cloud, or a .OBJ mesh file.
     *
     * @param {String} file The file URL
     * @param {String} type Can be either "obj" for .OBJ mesh file, or "point cloud" for csv point cloud.
     */
    module.viewData = function( file, type ) {
        if ( type == "obj" ) {
            mesh = new tools.Mesh( gl );

            var onload = function( model ) {
                tools.centerPointCloud( model.vertices.v );
                var verts = tools.unwrapArray( model.vertices.v, model.vertices.i );
                var norms;
                if ( model.normals.v.length == 0 ) {
                    norms = tools.vertexNormals( model.vertices.v, model.vertices.i );
                    norms = tools.unwrapArray( norms, model.vertices.i );
                } else {
                    norms = tools.unwrapArray( model.normals.v, model.normals.i );
                }

                var curvature = tools.surfaceVariation( verts, norms );
                var orientation = tools.surfaceOrientation( norms );

                mesh.meshFromArray( verts, norms, curvature, orientation );
                module.viewIlluminated();
                var aabb = tools.getAabb( model.vertices.v );
                camera.setBestPositionForModel( aabb );
            }

            tools.vertexArrayFromOBJ( file, onload );

        } else if ( type == "point cloud" ) {
            mesh = new tools.Mesh( gl );
            var onload = function( points ) {
                tools.centerPointCloud( points );
                var tris = tools.triangulate( points );

                var verts = tools.unwrapArray( points, tris );
                var norms = tools.vertexNormals( points, tris );
                norms = tools.unwrapArray( norms, tris );
                var curvature = tools.surfaceVariation( verts, norms );
                var orientation = tools.surfaceOrientation( norms );

                //mesh = new tools.Mesh( gl );
                mesh.meshFromArray( verts, norms, curvature, orientation );
                module.viewIlluminated();
                var aabb = tools.getAabb( points );
                camera.setBestPositionForModel( aabb );
            };

            tools.vertexArrayFromPointCloud( file, onload );

        } else if ( type == "tooth" ) {
            mesh = new tools.Mesh( gl );
            var onload = function( model ) {
                var verts = tools.unwrapArray( model.vertices.v, model.vertices.i );
                mesh.meshFromArray( verts, model.normals, model.curvature, model.orientation );
                module.viewIlluminated();
                var aabb = tools.getAabb( model.vertices.v );
                 camera.setBestPositionForModel( aabb );
            };

            tools.vertexArrayFromTOOTH( file, onload );

        } else {
            throw "morphoviewer.view: unrecognized 3d file type";
        }
    };

    /**
     * View the object as a wire frame model.
     * */
    module.viewWireframe = function() {
        currentProgram = wireframeProgram;
        currentProgram.use();
        mesh.bind();
        tools.wireframe.enableAttributes( gl, currentProgram );
        tools.wireframe.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.wireframe.camera = camera.matrix();
            tools.wireframe.model = modelView;
            tools.wireframe.setUniforms( currentProgram );
            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        };
    };

    /**
     * Color the surface of the object according to the discreet orientation of each polygon.
     * */
    module.viewSurfaceOrientation = function() {
        if ( currentProgram.object != colorProgram.object ) {
            currentProgram = colorProgram;
            currentProgram.use();
            setupColorShader();
        }
        tools.color.colorMode = 2;
    };

    /**
     * Color the surface of the object according to its local surface curvature.
     * */
    module.viewSurfaceCurvature = function() {
        if ( currentProgram.object != colorProgram.object ) {
            currentProgram = colorProgram;
            currentProgram.use();
            setupColorShader();
        }
        tools.color.colorMode = 1;
    };

    function setupColorShader() {
        mesh.bind();
        tools.color.enableAttributes( gl, currentProgram );
        tools.color.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.color.camera = camera.matrix();
            tools.color.model = modelView;
            tools.color.setUniforms( currentProgram );
            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    }

    module.viewIlluminated = function() {
        currentProgram = illuminationProgram;
        currentProgram.use();

        mesh.bind();
        tools.directional.enableAttributes( gl, currentProgram );
        tools.directional.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.directional.camera = camera.matrix();
            tools.directional.model = modelView;
            tools.directional.cameraPosition = camera.getPosition();
            tools.directional.setUniforms( currentProgram );

            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    };

    /**
     * View the model under a hemispherical light source.
     * */
    module.viewHemispherical = function() {
        currentProgram = hemisphereProgram;
        currentProgram.use();

        mesh.bind();
        tools.hemisphere.enableAttributes( gl, currentProgram );
        tools.hemisphere.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();

            tools.hemisphere.camera = camera.matrix();
            tools.hemisphere.model = modelView;
            tools.hemisphere.setUniforms( currentProgram );

            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    };

    /**
     * View with orthographic projection.
     */
    module.viewOrtho = function() {
        camera.viewAsOrtho();
    };


    /**
     * View with perspective projection.
     */
    module.viewPerspective = function() {
        camera.viewAsPerspective();
    };

    module.viewLeft = function() {
        camera.positionLeft();
    };

    module.viewRight = function() {
        camera.positionRight();
    };

    module.viewTop = function() {
        camera.positionTop();
    };

    module.viewBottom = function() {
        camera.positionBottom();
    };

    module.viewFront = function() {
        camera.positionFront();
    };

    module.viewBack = function() {
        camera.positionBack();
    };

    module.color = {
        black: vec3.fromValues(0.0, 0.0, 0.0),
        white: vec3.fromValues(1.0, 1.0, 1.0),
        lightgray: vec3.fromValues(0.91, 0.91, 0.91),
        lightgrey: vec3.fromValues(0.91, 0.91, 0.91),
        darkgray: vec3.fromValues(0.41, 0.41, 0.41),
        darkgrey: vec3.fromValues(0.41, 0.41, 0.41)
    };

    /**
     * Set the background color of the viewport.
     *
     * @param {vec3} color A vector containing the RGB color.
     * */
    module.setBackgroundColor = function( color ) {
        gl.clearColor(
            color[0],
            color[1],
            color[2],
            1.0
        );
    };

    module.setLightPolarAngle = function( theta ) {
        tools.hemisphere.polar = theta;
    };

    module.setLightAzimuthalAngle = function( phi ) {
        tools.hemisphere.azimuth = phi;
    };

    return module;
}( morphoviewer ));


