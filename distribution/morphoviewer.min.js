/*
The MIT License (MIT)

Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

External libraries used by Morphoviewer.js
---------------------------------------
Delaunay.js, which is public domain
gl-matrix is under the MIT license
jDataView is under the Do What The Fuck You Want license
*/
var Delaunay;(function(){"use strict";var EPSILON=1.0/1048576.0;function supertriangle(vertices){var xmin=Number.POSITIVE_INFINITY,ymin=Number.POSITIVE_INFINITY,xmax=Number.NEGATIVE_INFINITY,ymax=Number.NEGATIVE_INFINITY,i,dx,dy,dmax,xmid,ymid;for(i=vertices.length;i--;){if(vertices[i][0]<xmin)xmin=vertices[i][0];if(vertices[i][0]>xmax)xmax=vertices[i][0];if(vertices[i][1]<ymin)ymin=vertices[i][1];if(vertices[i][1]>ymax)ymax=vertices[i][1]}dx=xmax-xmin;dy=ymax-ymin;dmax=Math.max(dx,dy);xmid=xmin+dx*0.5;ymid=ymin+dy*0.5;return[[xmid-20*dmax,ymid-dmax],[xmid,ymid+20*dmax],[xmid+20*dmax,ymid-dmax]]}function circumcircle(vertices,i,j,k){var x1=vertices[i][0],y1=vertices[i][1],x2=vertices[j][0],y2=vertices[j][1],x3=vertices[k][0],y3=vertices[k][1],fabsy1y2=Math.abs(y1-y2),fabsy2y3=Math.abs(y2-y3),xc,yc,m1,m2,mx1,mx2,my1,my2,dx,dy;if(fabsy1y2<EPSILON&&fabsy2y3<EPSILON)throw new Error("Eek! Coincident points!");if(fabsy1y2<EPSILON){m2=-((x3-x2)/(y3-y2));mx2=(x2+x3)/2.0;my2=(y2+y3)/2.0;xc=(x2+x1)/2.0;yc=m2*(xc-mx2)+my2}else if(fabsy2y3<EPSILON){m1=-((x2-x1)/(y2-y1));mx1=(x1+x2)/2.0;my1=(y1+y2)/2.0;xc=(x3+x2)/2.0;yc=m1*(xc-mx1)+my1}else{m1=-((x2-x1)/(y2-y1));m2=-((x3-x2)/(y3-y2));mx1=(x1+x2)/2.0;mx2=(x2+x3)/2.0;my1=(y1+y2)/2.0;my2=(y2+y3)/2.0;xc=(m1*mx1-m2*mx2+my2-my1)/(m1-m2);yc=(fabsy1y2>fabsy2y3)?m1*(xc-mx1)+my1:m2*(xc-mx2)+my2}dx=x2-xc;dy=y2-yc;return{i:i,j:j,k:k,x:xc,y:yc,r:dx*dx+dy*dy}}function dedup(edges){var i,j,a,b,m,n;for(j=edges.length;j;){b=edges[--j];a=edges[--j];for(i=j;i;){n=edges[--i];m=edges[--i];if((a===m&&b===n)||(a===n&&b===m)){edges.splice(j,2);edges.splice(i,2);break}}}}Delaunay={triangulate:function(vertices,key){var n=vertices.length,i,j,indices,st,open,closed,edges,dx,dy,a,b,c;if(n<3)return[];vertices=vertices.slice(0);if(key)for(i=n;i--;)vertices[i]=vertices[i][key];indices=new Array(n);for(i=n;i--;)indices[i]=i;indices.sort(function(i,j){return vertices[j][0]-vertices[i][0]});st=supertriangle(vertices);vertices.push(st[0],st[1],st[2]);open=[circumcircle(vertices,n+0,n+1,n+2)];closed=[];edges=[];for(i=indices.length;i--;edges.length=0){c=indices[i];for(j=open.length;j--;){dx=vertices[c][0]-open[j].x;if(dx>0.0&&dx*dx>open[j].r){closed.push(open[j]);open.splice(j,1);continue}dy=vertices[c][1]-open[j].y;if(dx*dx+dy*dy-open[j].r>EPSILON)continue;edges.push(open[j].i,open[j].j,open[j].j,open[j].k,open[j].k,open[j].i);open.splice(j,1)}dedup(edges);for(j=edges.length;j;){b=edges[--j];a=edges[--j];open.push(circumcircle(vertices,a,b,c))}}for(i=open.length;i--;)closed.push(open[i]);open.length=0;for(i=closed.length;i--;)if(closed[i].i<n&&closed[i].j<n&&closed[i].k<n)open.push(closed[i].i,closed[i].j,closed[i].k);return open},contains:function(tri,p){if((p[0]<tri[0][0]&&p[0]<tri[1][0]&&p[0]<tri[2][0])||(p[0]>tri[0][0]&&p[0]>tri[1][0]&&p[0]>tri[2][0])||(p[1]<tri[0][1]&&p[1]<tri[1][1]&&p[1]<tri[2][1])||(p[1]>tri[0][1]&&p[1]>tri[1][1]&&p[1]>tri[2][1]))return null;var a=tri[1][0]-tri[0][0],b=tri[2][0]-tri[0][0],c=tri[1][1]-tri[0][1],d=tri[2][1]-tri[0][1],i=a*d-b*c;if(i===0.0)return null;var u=(d*(p[0]-tri[0][0])-b*(p[1]-tri[0][1]))/i,v=(a*(p[1]-tri[0][1])-c*(p[0]-tri[0][0]))/i;if(u<0.0||v<0.0||(u+v)>1.0)return null;return[u,v]}};if(typeof module!=="undefined")module.exports=Delaunay})();
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s=Math.PI/180;i.toRadian=function(e){return e*s};var o={};o.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},o.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},o.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},o.set=function(e,t,n){return e[0]=t,e[1]=n,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},o.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},o.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},o.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),o.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=o);var u={};u.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},u.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},u.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},u.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},u.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},u.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},u.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.rotateX=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0],s[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),s[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateY=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateZ=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),s[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),s[2]=i[2],e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),u.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=u);var a={};a.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},a.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},a.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},a.sub=a.subtract,a.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},a.mul=a.multiply,a.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},a.div=a.divide,a.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},a.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},a.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},a.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},a.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},a.dist=a.distance,a.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},a.sqrDist=a.squaredDistance,a.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},a.len=a.length,a.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},a.sqrLen=a.squaredLength,a.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},a.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},a.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},a.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},a.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),a.normalize(e,e),a.scale(e,e,t),e},a.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},a.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},a.forEach=function(){var e=a.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),a.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=a);var f={};f.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},f.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},f.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+s*a,e[1]=i*u+o*a,e[2]=r*f+s*l,e[3]=i*f+o*l,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+s*u,e[1]=i*a+o*u,e[2]=r*-u+s*a,e[3]=i*-u+o*a,e},f.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*u,e[2]=s*a,e[3]=o*a,e},f.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},f.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2))},f.LDU=function(e,t,n,r){return e[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-e[2]*n[1],[e,t,n]},typeof e!="undefined"&&(e.mat2=f);var l={};l.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},l.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+s*l,e[1]=i*f+o*l,e[2]=r*c+s*h,e[3]=i*c+o*h,e[4]=r*p+s*d+u,e[5]=i*p+o*d+a,e},l.mul=l.multiply,l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+s*f,e[1]=i*l+o*f,e[2]=r*-f+s*l,e[3]=i*-f+o*l,e[4]=u,e[5]=a,e},l.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r*f,e[1]=i*f,e[2]=s*l,e[3]=o*l,e[4]=u,e[5]=a,e},l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=r*f+s*l+u,e[5]=i*f+o*l+a,e},l.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},l.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+1)},typeof e!="undefined"&&(e.mat2d=l);var c={};c.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},c.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},c.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},c.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[3]=l-g,e[6]=h+m,e[1]=l+g,e[4]=1-f-d,e[7]=p-v,e[2]=h-m,e[5]=p+v,e[8]=1-f-c,e},c.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},c.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},c.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2))},typeof e!="undefined"&&(e.mat3=c);var h={};h.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},h.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},h.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},h.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},h.mul=h.multiply,h.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},h.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},h.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},h.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},h.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},h.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},h.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[1]=l+g,e[2]=h-m,e[3]=0,e[4]=l-g,e[5]=1-f-d,e[6]=p+v,e[7]=0,e[8]=h+m,e[9]=p-v,e[10]=1-f-c,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},h.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},h.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},h.lookAt=function(e,n,r,i){var s,o,u,a,f,l,c,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?h.identity(e):(c=m-S,p=g-x,d=y-T,v=1/Math.sqrt(c*c+p*p+d*d),c*=v,p*=v,d*=v,s=w*d-E*p,o=E*c-b*d,u=b*p-w*c,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-c*u,l=c*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=c,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(c*m+p*g+d*y),e[15]=1,e)},h.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},h.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2)+Math.pow(e[9],2)+Math.pow(e[10],2)+Math.pow(e[11],2)+Math.pow(e[12],2)+Math.pow(e[13],2)+Math.pow(e[14],2)+Math.pow(e[15],2))},typeof e!="undefined"&&(e.mat4=h);var p={};p.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.rotationTo=function(){var e=u.create(),t=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,i,s){var o=u.dot(i,s);return o<-0.999999?(u.cross(e,t,i),u.length(e)<1e-6&&u.cross(e,n,i),u.normalize(e,e),p.setAxisAngle(r,e,Math.PI),r):o>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+o,p.normalize(r,r))}}(),p.setAxes=function(){var e=c.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],p.normalize(t,p.fromMat3(t,e))}}(),p.clone=a.clone,p.fromValues=a.fromValues,p.copy=a.copy,p.set=a.set,p.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},p.add=a.add,p.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},p.mul=p.multiply,p.scale=a.scale,p.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},p.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},p.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},p.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},p.dot=a.dot,p.lerp=a.lerp,p.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},p.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},p.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},p.length=a.length,p.len=p.length,p.squaredLength=a.squaredLength,p.sqrLen=p.squaredLength,p.normalize=a.normalize,p.fromMat3=function(e,t){var n=t[0]+t[4]+t[8],r;if(n>0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[7]-t[5])*r,e[1]=(t[2]-t[6])*r,e[2]=(t[3]-t[1])*r;else{var i=0;t[4]>t[0]&&(i=1),t[8]>t[i*3+i]&&(i=2);var s=(i+1)%3,o=(i+2)%3;r=Math.sqrt(t[i*3+i]-t[s*3+s]-t[o*3+o]+1),e[i]=.5*r,r=.5/r,e[3]=(t[o*3+s]-t[s*3+o])*r,e[s]=(t[s*3+i]+t[i*3+s])*r,e[o]=(t[o*3+i]+t[i*3+o])*r}return e},p.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=p)}(t.exports)})(this);

!function(a){var b=this;"object"==typeof exports?module.exports=a(b):"function"==typeof define&&define.amd?define([],function(){return a(b)}):b.jDataView=a(b)}(function(a){"use strict";function b(a,b){return!b&&a instanceof Array?a:Array.prototype.slice.call(a)}function c(a,b){return void 0!==a?a:b}function d(a,b,e,f){if(a instanceof d){var g=a.slice(b,b+e);return g._littleEndian=c(f,g._littleEndian),g}if(!(this instanceof d))return new d(a,b,e,f);if(this.buffer=a=d.wrapBuffer(a),this._isArrayBuffer=i.ArrayBuffer&&a instanceof ArrayBuffer,this._isPixelData=!0&&i.PixelData&&a instanceof CanvasPixelArray,this._isDataView=i.DataView&&this._isArrayBuffer,this._isNodeBuffer=!1,!(this._isArrayBuffer||this._isPixelData||a instanceof Array))throw new TypeError("jDataView buffer has an incompatible type");this._littleEndian=!!f;var h="byteLength"in a?a.byteLength:a.length;this.byteOffset=b=c(b,0),this.byteLength=e=c(e,h-b),this._offset=this._bitOffset=0,this._isDataView?this._view=new DataView(a,b,e):this._checkBounds(b,e,h),this._engineAction=this._isDataView?this._dataViewAction:this._isArrayBuffer?this._arrayBufferAction:this._arrayAction}function e(a){for(var b=i.ArrayBuffer?Uint8Array:Array,c=new b(a.length),d=0,e=a.length;e>d;d++)c[d]=255&a.charCodeAt(d);return c}function f(a){return a>=0&&31>a?1<<a:f[a]||(f[a]=Math.pow(2,a))}function g(a,b){this.lo=a,this.hi=b}function h(){g.apply(this,arguments)}var i={NodeBuffer:!1,DataView:"DataView"in a,ArrayBuffer:"ArrayBuffer"in a,PixelData:!0&&"CanvasPixelArray"in a&&"ImageData"in a&&"document"in a},j=a.TextEncoder,k=a.TextDecoder;if(i.PixelData){var l=function(a,b){var c=l.context2d.createImageData((a+3)/4,1).data;if(c.byteLength=a,void 0!==b)for(var d=0;a>d;d++)c[d]=b[d];return c};l.context2d=document.createElement("canvas").getContext("2d")}var m={Int8:1,Int16:2,Int32:4,Uint8:1,Uint16:2,Uint32:4,Float32:4,Float64:8};d.wrapBuffer=function(a){switch(typeof a){case"number":if(i.ArrayBuffer)a=new Uint8Array(a).buffer;else if(i.PixelData)a=l(a);else{a=new Array(a);for(var c=0;c<a.length;c++)a[c]=0}return a;case"string":a=e(a);default:return"length"in a&&!(i.ArrayBuffer&&a instanceof ArrayBuffer||i.PixelData&&a instanceof CanvasPixelArray)&&(i.ArrayBuffer?a instanceof ArrayBuffer||(a=new Uint8Array(a).buffer,a instanceof ArrayBuffer||(a=new Uint8Array(b(a,!0)).buffer)):a=i.PixelData?l(a.length,a):b(a)),a}},d.createBuffer=function(){return d.wrapBuffer(arguments)},d.Uint64=g,g.prototype={valueOf:function(){return this.lo+f(32)*this.hi},toString:function(){return Number.prototype.toString.apply(this.valueOf(),arguments)}},g.fromNumber=function(a){var b=Math.floor(a/f(32)),c=a-b*f(32);return new g(c,b)},d.Int64=h,h.prototype="create"in Object?Object.create(g.prototype):new g,h.prototype.valueOf=function(){return this.hi<f(31)?g.prototype.valueOf.apply(this,arguments):-(f(32)-this.lo+f(32)*(f(32)-1-this.hi))},h.fromNumber=function(a){var b,c;if(a>=0){var d=g.fromNumber(a);b=d.lo,c=d.hi}else c=Math.floor(a/f(32)),b=a-c*f(32),c+=f(32);return new h(b,c)};var n=d.prototype={compatibility:i,_checkBounds:function(a,b,d){if("number"!=typeof a)throw new TypeError("Offset is not a number.");if("number"!=typeof b)throw new TypeError("Size is not a number.");if(0>b)throw new RangeError("Length is negative.");if(0>a||a+b>c(d,this.byteLength))throw new RangeError("Offsets are out of bounds.")},_action:function(a,b,d,e,f){return this._engineAction(a,b,c(d,this._offset),c(e,this._littleEndian),f)},_dataViewAction:function(a,b,c,d,e){return this._offset=c+m[a],b?this._view["get"+a](c,d):this._view["set"+a](c,e,d)},_arrayBufferAction:function(b,d,e,f,g){var h,i=m[b],j=a[b+"Array"];if(f=c(f,this._littleEndian),1===i||(this.byteOffset+e)%i===0&&f)return h=new j(this.buffer,this.byteOffset+e,1),this._offset=e+i,d?h[0]:h[0]=g;var k=new Uint8Array(d?this.getBytes(i,e,f,!0):i);return h=new j(k.buffer,0,1),d?h[0]:(h[0]=g,void this._setBytes(e,k,f))},_arrayAction:function(a,b,c,d,e){return b?this["_get"+a](c,d):this["_set"+a](c,e,d)},_getBytes:function(a,d,e){e=c(e,this._littleEndian),d=c(d,this._offset),a=c(a,this.byteLength-d),this._checkBounds(d,a),d+=this.byteOffset,this._offset=d-this.byteOffset+a;var f=this._isArrayBuffer?new Uint8Array(this.buffer,d,a):(this.buffer.slice||Array.prototype.slice).call(this.buffer,d,d+a);return e||1>=a?f:b(f).reverse()},getBytes:function(a,d,e,f){var g=this._getBytes(a,d,c(e,!0));return f?b(g):g},_setBytes:function(a,d,e){var f=d.length;if(0!==f){if(e=c(e,this._littleEndian),a=c(a,this._offset),this._checkBounds(a,f),!e&&f>1&&(d=b(d,!0).reverse()),a+=this.byteOffset,this._isArrayBuffer)new Uint8Array(this.buffer,a,f).set(d);else for(var g=0;f>g;g++)this.buffer[a+g]=d[g];this._offset=a-this.byteOffset+f}},setBytes:function(a,b,d){this._setBytes(a,b,c(d,!0))},getString:function(a,b,c){var d=this._getBytes(a,b,!0);if(c="utf8"===c?"utf-8":c||"binary",k&&"binary"!==c)return new k(c).decode(this._isArrayBuffer?d:new Uint8Array(d));var e="";a=d.length;for(var f=0;a>f;f++)e+=String.fromCharCode(d[f]);return"utf-8"===c&&(e=decodeURIComponent(escape(e))),e},setString:function(a,b,c){c="utf8"===c?"utf-8":c||"binary";var d;j&&"binary"!==c?d=new j(c).encode(b):("utf-8"===c&&(b=unescape(encodeURIComponent(b))),d=e(b)),this._setBytes(a,d,!0)},getChar:function(a){return this.getString(1,a)},setChar:function(a,b){this.setString(a,b)},tell:function(){return this._offset},seek:function(a){return this._checkBounds(a,0),this._offset=a},skip:function(a){return this.seek(this._offset+a)},slice:function(a,b,e){function f(a,b){return 0>a?a+b:a}return a=f(a,this.byteLength),b=f(c(b,this.byteLength),this.byteLength),e?new d(this.getBytes(b-a,a,!0,!0),void 0,void 0,this._littleEndian):new d(this.buffer,this.byteOffset+a,b-a,this._littleEndian)},alignBy:function(a){return this._bitOffset=0,1!==c(a,1)?this.skip(a-(this._offset%a||a)):this._offset},_getFloat64:function(a,b){var c=this._getBytes(8,a,b),d=1-2*(c[7]>>7),e=((c[7]<<1&255)<<3|c[6]>>4)-1023,g=(15&c[6])*f(48)+c[5]*f(40)+c[4]*f(32)+c[3]*f(24)+c[2]*f(16)+c[1]*f(8)+c[0];return 1024===e?0!==g?0/0:1/0*d:-1023===e?d*g*f(-1074):d*(1+g*f(-52))*f(e)},_getFloat32:function(a,b){var c=this._getBytes(4,a,b),d=1-2*(c[3]>>7),e=(c[3]<<1&255|c[2]>>7)-127,g=(127&c[2])<<16|c[1]<<8|c[0];return 128===e?0!==g?0/0:1/0*d:-127===e?d*g*f(-149):d*(1+g*f(-23))*f(e)},_get64:function(a,b,d){d=c(d,this._littleEndian),b=c(b,this._offset);for(var e=d?[0,4]:[4,0],f=0;2>f;f++)e[f]=this.getUint32(b+e[f],d);return this._offset=b+8,new a(e[0],e[1])},getInt64:function(a,b){return this._get64(h,a,b)},getUint64:function(a,b){return this._get64(g,a,b)},_getInt32:function(a,b){var c=this._getBytes(4,a,b);return c[3]<<24|c[2]<<16|c[1]<<8|c[0]},_getUint32:function(a,b){return this._getInt32(a,b)>>>0},_getInt16:function(a,b){return this._getUint16(a,b)<<16>>16},_getUint16:function(a,b){var c=this._getBytes(2,a,b);return c[1]<<8|c[0]},_getInt8:function(a){return this._getUint8(a)<<24>>24},_getUint8:function(a){return this._getBytes(1,a)[0]},_getBitRangeData:function(a,b){var d=(c(b,this._offset)<<3)+this._bitOffset,e=d+a,f=d>>>3,g=e+7>>>3,h=this._getBytes(g-f,f,!0),i=0;(this._bitOffset=7&e)&&(this._bitOffset-=8);for(var j=0,k=h.length;k>j;j++)i=i<<8|h[j];return{start:f,bytes:h,wideValue:i}},getSigned:function(a,b){var c=32-a;return this.getUnsigned(a,b)<<c>>c},getUnsigned:function(a,b){var c=this._getBitRangeData(a,b).wideValue>>>-this._bitOffset;return 32>a?c&~(-1<<a):c},_setBinaryFloat:function(a,b,c,d,e){var g,h,i=0>b?1:0,j=~(-1<<d-1),k=1-j;0>b&&(b=-b),0===b?(g=0,h=0):isNaN(b)?(g=2*j+1,h=1):1/0===b?(g=2*j+1,h=0):(g=Math.floor(Math.log(b)/Math.LN2),g>=k&&j>=g?(h=Math.floor((b*f(-g)-1)*f(c)),g+=j):(h=Math.floor(b/f(k-c)),g=0));for(var l=[];c>=8;)l.push(h%256),h=Math.floor(h/256),c-=8;for(g=g<<c|h,d+=c;d>=8;)l.push(255&g),g>>>=8,d-=8;l.push(i<<d|g),this._setBytes(a,l,e)},_setFloat32:function(a,b,c){this._setBinaryFloat(a,b,23,8,c)},_setFloat64:function(a,b,c){this._setBinaryFloat(a,b,52,11,c)},_set64:function(a,b,d,e){d instanceof a||(d=a.fromNumber(d)),e=c(e,this._littleEndian),b=c(b,this._offset);var f=e?{lo:0,hi:4}:{lo:4,hi:0};for(var g in f)this.setUint32(b+f[g],d[g],e);this._offset=b+8},setInt64:function(a,b,c){this._set64(h,a,b,c)},setUint64:function(a,b,c){this._set64(g,a,b,c)},_setUint32:function(a,b,c){this._setBytes(a,[255&b,b>>>8&255,b>>>16&255,b>>>24],c)},_setUint16:function(a,b,c){this._setBytes(a,[255&b,b>>>8&255],c)},_setUint8:function(a,b){this._setBytes(a,[255&b])},setUnsigned:function(a,b,c){var d=this._getBitRangeData(c,a),e=d.wideValue,f=d.bytes;e&=~(~(-1<<c)<<-this._bitOffset),e|=(32>c?b&~(-1<<c):b)<<-this._bitOffset;for(var g=f.length-1;g>=0;g--)f[g]=255&e,e>>>=8;this._setBytes(d.start,f,!0)}};for(var o in m)!function(a){n["get"+a]=function(b,c){return this._action(a,!0,b,c)},n["set"+a]=function(b,c,d){this._action(a,!1,b,d,c)}}(o);n._setInt32=n._setUint32,n._setInt16=n._setUint16,n._setInt8=n._setUint8,n.setSigned=n.setUnsigned;for(var p in n)"set"===p.slice(0,3)&&!function(a){n["write"+a]=function(){Array.prototype.unshift.call(arguments,void 0),this["set"+a].apply(this,arguments)}}(p.slice(3));return d});
/*
 Copyright (c) 2014 Johann Muszynski

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.*/

/**
 * @namespace The parsers namespace provides utilities for parsing .OBJ, text csv point
 * clouds, and .PLY (binary and ASCII files )
 */

var parsers = ( function( module ) {

    function loadFile( file, onload ) {
        var request = new XMLHttpRequest();
        request.open( "GET", file, true );	//gets performed asynchronously
        request.responseType = "arraybuffer";
        request.onload = function ( e ) { onload( e.target.response ); };
        request.send();
    }

    /**
     * Get a line from a binary buffer. The newline character is not concatenated to the result.
     *
     * @param {Uint8Array} buffer
     * @param {Number} offset get line after an offset, specified in bytes*/
    function readLine( buffer, offset ) {
        var view = jDataView( buffer );
        if ( typeof(offset) === "undefined" ) {
            offset = 0;
        }
        view.seek( offset );
        var res = "";
        var ch = view.getChar();
        while ( ch != '\n' ) {
            res = res.concat( ch );
            ch = view.getChar();
        }
        return res;
    }

    ////////////////////////////////////////////////////////////////////////////////
    // PLY parser methods & prototypes
    ////////////////////////////////////////////////////////////////////////////////

    var byteSizePLY = {
        "char": 1,
        "uchar": 1,
        "short": 2,
        "ushort": 2,
        "int": 4,
        "uint": 4,
        "float": 4,
        "double": 8
    };

    var byteSymbolPLY = {
        "char": "c",
        "uchar": "B",
        "short": "h",
        "ushort": "H",
        "int": "i",
        "uint": "I",
        "float": "f",
        "double": "d"
    };

    var TokenStream = function() {
        this.tokenStream = [];
        this.index = 0;
        this.end = 0;
    };

    TokenStream.prototype.append = function( token ) {
        this.tokenStream.push( token );
        this.end++;
    };

    TokenStream.prototype.get = function() {
        var res = this.tokenStream[this.index];
        this.index++;
        if ( this.index >= this.end ) {
            this.index = this.end;
        }
        return res;
    };

    TokenStream.prototype.peek = function( count ) {
        if ( typeof(count) === "undefined" ) {
            count = 0;
        }
        if ( this.index + count == this.end ) {
            return this.tokenStream[this.end];
        }
        return this.tokenStream[this.index+count];
    };

    var PLYElementParser = function() {};

    var PLYBinaryElementParser = function() {
        //
    };

    var PLYScalarPropertyParser = function() {};

    var PLYBinaryScalarPropertyParser = function() {
        //
    };

    var PLYListPropertyParser = function() {};

    var PLYBinaryListPropertyParser = function() {
        //
    };

    /**
     * @param {Array} tokens the array of string tokens to be added to the token stream
     * @param {TokenStream} tokenStream
     * @returns {Boolean} false, if we reached the "end_header" token, true otherwise*/
    function tokenizePLYLine( tokens, tokenStream ) {
        for ( var i = 0; i < tokens.length; i++ ) {
            var token = tokens[i];
            if ( token === "ply" || token === "comment" ) {
                continue;
            }
            tokenStream.append( token );

            if ( token === "end_header" ) {
                return false;
            }
        }
        return true;
    }

    /**
     * Turn the PLY header into a stream of tokens.
     *
     * @param {Uint8Array} buffer
     * @returns {Array} the byte offset of the header, and the TokenStream object representing the header*/
    function tokenizePLYHeader( buffer ) {
        var offset = 0;
        var tokenStream = new TokenStream();
        // offset is length + 1 because the newline character is stripped from the result
        var line = readLine( buffer, 0 );
        offset += line.length + 1;
        var tokens = line.split(" ");
        while ( tokenizePLYLine( tokens, tokenStream ) ) {
            line = readLine( buffer, offset );
            offset += line.length + 1;
            tokens = line.split(" ");
        }

        return [ offset, tokenStream ];
    }

    function parsePLYHeader( tokenStream ) {
        var endianness = '';
        var resultDict = {};
        var elementParsers = [];
        while ( true ) {
            var token = tokenStream.get();
            if ( token === "format" ) {
                endianness = parseFormat( tokenStream );
            } else if ( token === "element" ) {
                elementParsers.append( parseElement(tokenStream, resultDict, endianness) );
            } else if ( token === "end_header" ) {
                break;
            }
        }
    }

    function parsePLYData() {}

    function parseFormat( tokenStream ) {}

    function parseElement( tokenStream, resultDict, endianness ) {}

    function parseProperty( tokenStream ) {}

    function parsePLY( file ) {
        var buffer = new Uint8Array( file );
        var tokenization = tokenizePLYHeader( buffer );
        var tokenStream = tokenization[1];
        var offset = tokenization[0];
        console.log("The offset is " + offset );
        console.log("The tokens are: ");
        for ( var i = 0; i < tokenStream.end; i++ ) {
            console.log( tokenStream.get() );
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // OBJ parser methods & prototypes
    ////////////////////////////////////////////////////////////////////////////////

    function parseOBJ( file ) {
        //
    }


    module.load = function( file, type, onload ) {
        //var parts = file.split('.');

        var loader = function( data ) {
            var model = parsePLY( data );

            if ( onload != undefined ) {
                onload( model );
            }
        };

        loadFile( file, loader );
    };

    return module;
}( parsers || {} ) );

/*
Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/

/*This file (morphoviewer mesh tools) contains tools for loading point clouds, mesh files, and generating
* vertex data (vertex normals, face normals, surface curvature, surface orientation)
* for them.*/
var morphoviewer = ( function( module ) {

    var EPSILON = 1.0 / 1048576.0;

    function loadFile( file, onload ) {
        var request = new XMLHttpRequest();
        request.open( "GET", file, true );	//gets performed asynchronously
        request.responseType = "arraybuffer";
        request.onload = function ( e ) { onload( e.target.response); };
        request.send();
    }

    /**
     * Load and parse a vertex array from an .OBJ file.
     *
     * @param {String} file the file which we want to load
     * @param {Function} onload the function passes the following object to
     * onload: { vertices: {Array}, normals: {Array}, indices: {Array} }, where the
     * first two are arrays of triplets, each triplet representing a point or normal,
     * respectively. The indices array is an array of triplets containing indices, specifying
     * how the mesh is triangulated.
     */
    module.vertexArrayFromOBJ = function( file, onload ) {
        var loader = function( data ) {
            var model = parseOBJ( data );

            if ( onload != undefined ) {
                onload( model );
            }
        };

        loadFile( file, loader );
    };

    /**
     * Load a point cloud file into a vertex array.
     *
     * @param {String} file
     * @param {Function} onload this function gets passed as the single argument an array of triplets
     * @param {String} delimiter the delimiter used in the point cloud file to separate values (comma by default)
     */
    module.vertexArrayFromPointCloud = function( file, onload, delimiter ) {
        if ( typeof(delimiter) === 'undefined' ) {
            delimiter = ',';
        }

        var loader = function( data ) {
            var points = parsePointCloud( data, delimiter );

            if ( onload != undefined ) {
                onload( points )
            }
        };

        loadFile( file, loader );
    };

    /*Parses a buffer containing a point cloud in xyz format.
     * Returns them in an array of triplets*/
    function parsePointCloud( buffer, delimiter ) {
        var p = [];

        var a = new Uint8Array( buffer );
        var off = 0.0;

        while ( off < a.length ) {
            var line = readLine( a, off );
            off += line.length + 1;

            var tokens = line.split( delimiter );
            p.push( [
                parseFloat( tokens[0] ),
                parseFloat( tokens[1] ),
                parseFloat( tokens[2] )
            ] );
        }

        return p;
    }

    module.vertexArrayFromMorphobuffer = function( file, onload ) {
        var loader = function( buffer ) {
            var model = parseMorphobuffer( buffer );
            if ( onload != undefined ) {
                onload( model );
            }
        };

        loadFile( file, loader );
    };

    function parseMorphobuffer( buffer ) {
        var bytes = new Uint8Array( buffer );
        var m = {
            vertices: { v: [], i: [] },
            normals: [],
            curvature: [],
            orientation: []
        };
        var view = jDataView( bytes );
        while ( view.tell() < bytes.length ) {
            //get the identifier of the following bytes
            var c = view.getChar();
            if ( c == "v" ) {
                m.vertices.v.push([
                    view.getFloat64(),
                    view.getFloat64(),
                    view.getFloat64()
                ]);
            } else if ( c == 't' ) {
                m.vertices.i.push([
                    view.getUint32(),
                    view.getUint32(),
                    view.getUint32()
                ]);
            } else if ( c == 'n' ) {
                m.normals.push([
                    view.getFloat64(),
                    view.getFloat64(),
                    view.getFloat64()
                ]);
            } else if ( c == 'c' ) {
                var curves = view.getFloat64();
                m.curvature.push( curves );
                m.curvature.push( curves );
                m.curvature.push( curves );
            } else if ( c == 'o' ) {
                m.orientation.push( view.getFloat64() );
            }
        }
        return m;
    }

    /*Parses a buffer containing data from a wavefront .OBJ file
     * Returns vertices, their triangulation, and vertex normals, if possible
     * This parser does not do anything with groups.*/
    function parseOBJ( buffer ) {
        //the model
        var m = { vertices: { v: [], i: [] }, normals: { v: [], i: [] } };

        var offset = 0.0;
        var chars = new Uint8Array( buffer );

        while ( offset < chars.length ) {
            var line = readLine( chars, offset );
            offset += line.length + 1;
            line = line.replace(/ +(?= )/g,'');
            line = line.replace(/(^\s+|\s+$)/g, '');
            var tokens = line.split(" ");

            if ( tokens[0] == "v" ) {
                m.vertices.v.push( [
                    parseFloat( tokens[1] ),
                    parseFloat( tokens[2] ),
                    parseFloat( tokens[3] )
                ] );
            }
            if ( tokens[0] == "vn" ) {
                m.normals.v.push( [
                    parseFloat( tokens[1] ),
                    parseFloat( tokens[2] ),
                    parseFloat( tokens[3] )
                ] );
            }
            if ( tokens[0] == "f" ) {
                var vlen = m.vertices.v.length;
                var nlen = m.normals.v.length;
                var i1 = tokens[1].split("/");

                if ( i1.length == 1 ) {
                    i1 = parseInt( i1 ) - 1;
                    if ( i1 < 0 ) i1 = vlen + i1 + 1;
                    for ( var j = 2; j < tokens.length - 1; j ++ ) {
                        var i2 = parseInt( tokens[j] ) - 1;
                        var i3 = parseInt( tokens[j+1] ) - 1;
                        if ( i2 < 0 ) {
                            i2 = vlen + i2 + 1;
                            i3 = vlen + i3 + 1;
                        }
                        m.vertices.i.push( [i1, i2, i3] );
                        if ( m.normals.v.length > 0 ) {
                            m.normals.i.push( [i1, i2, i3] );
                        }
                    }
                } else {
                    var vi1 = parseInt( i1[0] ) - 1;
                    var ni1 = parseInt( i1[2] ) - 1;

                    if ( vi1 < 0 ) vi1 = vlen + vi1 + 1;
                    if ( ni1 < 0 ) ni1 = nlen + ni1 + 1;

                    //general case for handling convex polygons
                    for ( var j = 2; j < tokens.length - 1; j++ ) {
                        //get the next two vertices of the triangle
                        var i2 = tokens[j].split("/");
                        var i3 = tokens[j+1].split("/");
                        var vi2 = parseInt( i2[0] ) - 1;
                        var vi3 = parseInt( i3[0] ) - 1;
                        var ni2 = parseInt( i2[2] ) - 1;
                        var ni3 = parseInt( i3[2] ) - 1;
                        //handle face definition using negative indices
                        if ( vi2 < 0 ) {
                            vi2 = vlen + vi2 + 1;
                            vi3 = vlen + vi3 + 1;
                        }
                        if ( ni2 < 0 ) {
                            ni2 = nlen + ni2 + 1;
                            ni3 = nlen + ni3 + 1;
                        }
                        m.vertices.push( [vi1, vi2, vi3] );
                        m.normals.push( [ni1, ni2, ni3] );
                    }
                }
            }
        }

        return m;
    }

    /*chars is {Uint8Array} and offset is {Number}*/
    function readLine( chars, offset ) {
        var s = "";
        while( chars[ offset ] != 10 ) {
            s += String.fromCharCode( chars[ offset++ ] );
        }
        return s;
    }

    function centerOfVolume( points ) {
        var covX = 0.0;	//center of colume for each coordinate
        var covY = 0.0;
        var covZ = 0.0;

        for ( var i = 0; i < points.length; i++ ) {
            covX += points[i][0];
            covY += points[i][1];
            covZ += points[i][2];
        }

        covX /= points.length;
        covY /= points.length;
        covZ /= points.length;
        return [ covX, covY, covZ ];
    }

    /**
     * Center the point cloud on the origin.
     *
     * @param {Array} points an array of triplets, each triplet representing a (x, y, z) point.
     */
    module.centerPointCloud = function( points ) {
        var cov = centerOfVolume( points );

        for ( var i = 0; i < points.length; i++ ) {
            points[i][0] -= cov[0];
            points[i][1] -= cov[1];
            points[i][2] -= cov[2];
        }
    };

    /**
     * Get the unwrapped (containing repeated vertices) array
     *
     * @returns {Array} the unwrapped array of vertex coordinates.
     */
    module.unwrapVectorArray = function( v, inds ) {
        var verts = [];
        for ( var i = 0; i < inds.length; i++ ) {
            /*if ( inds[i][0] >= v.length || inds[i][1] >= v.length || inds[i][2] >= v.length ) {
                console.log( inds[i][0] + " " + inds[i][1] + " " + inds[i][2] + ", length: " + v.length );
                throw "MESH FAILURE";
            }*/
            verts.push( v[inds[i][0]][0], v[inds[i][0]][1], v[inds[i][0]][2] );	//first vertex
            verts.push( v[inds[i][1]][0], v[inds[i][1]][1], v[inds[i][1]][2] );	//second vertex
            verts.push( v[inds[i][2]][0], v[inds[i][2]][1], v[inds[i][2]][2] );	//third vertex
        }
        return verts;
    };

    module.unwrapArray = function( v, inds ) {
        var values = [];
        for ( var i = 0; i < inds.length; i++ ) {
            values.push(
                v[ inds[i][0] ],
                v[ inds[i][1] ],
                v[ inds[i][2] ]
            );
        }
        return values;
    };

    /**
     * Finds the min and max points of an array of vertices.
     *
     * @returns {Object} an object containing min and max fields, each containing x, y, and z fields.
     */
    module.getAabb = function( verts ) {
        var xmin = Number.POSITIVE_INFINITY,
            xmax = Number.NEGATIVE_INFINITY,
            ymin = Number.POSITIVE_INFINITY,
            ymax = Number.NEGATIVE_INFINITY,
            zmin = Number.POSITIVE_INFINITY,
            zmax = Number.NEGATIVE_INFINITY;

        for ( var i = 0; i < verts.length; i++ ) {
            if ( verts[i][0] < xmin ) { xmin = verts[i][0]; }
            if ( verts[i][0] > xmax ) { xmax = verts[i][0]; }
            if ( verts[i][1] < ymin ) { ymin = verts[i][1]; }
            if ( verts[i][1] > ymax ) { ymax = verts[i][1]; }
            if ( verts[i][2] < zmin ) { zmin = verts[i][2]; }
            if ( verts[i][2] > zmax ) { zmax = verts[i][2]; }
        }

        return {
            min: { x: xmin, y: ymin, z: zmin },
            max: { x: xmax, y: ymax, z: zmax },
            center: { x: xmin+xmax / 2.0, y: ymin+ymax / 2.0, z: zmin+zmax / 2.0 }
        };
    };

    /**
     * Build a triangulated mesh out of a set of points.
     *
     * @param {Array} verts an array of triplets, where each triplet represents a point coordinate
     * @returns {Array} an array containing triplets of indices denoting triangles
     */
    module.triangulate = function( verts ) {
        var unwrapped_tris = Delaunay.triangulate( verts );
        var tris = [];
        for ( var i = 0; i < unwrapped_tris.length; i+=3 ) {
            tris.push( [
                unwrapped_tris[i],
                unwrapped_tris[i+1],
                unwrapped_tris[i+2]
            ]);
        }
        return tris;
    };
    /**
     * Calculates face normals for each triangle. This operation has O(N) time
     * complexity.
     *
     * @param {Array} verts an array of coordinates, arranged in triplets for each point.
     * @param {Array} ind an array of indices, arranged in triplets
     * @returns {Array} an array which matches a normal with each vertex in the input array.
     */
    module.faceNormals = function( verts, ind ) {
        var norms = new Array( verts.length );
        for ( var i = 0; i < ind.length; i++ ) {
            var a = vec3.fromValues(
                    verts[ ind[i][1] ][0] - verts[ ind[i][0] ][0],
                    verts[ ind[i][1] ][1] - verts[ ind[i][0] ][1],
                    verts[ ind[i][1] ][2] - verts[ ind[i][0] ][2]
            );
            var b = vec3.fromValues(
                    verts[ ind[i][2] ][0] - verts[ ind[i][0] ][0],
                    verts[ ind[i][2] ][1] - verts[ ind[i][0] ][1],
                    verts[ ind[i][2] ][2] - verts[ ind[i][0] ][2]
            );
            var n = vec3.cross( vec3.create(), a, b );
            vec3.normalize( n, n );

            norms[ ind[i][0] ] = [ n[0], n[1], n[2] ];
            norms[ ind[i][1] ] = [ n[0], n[1], n[2] ];
            norms[ ind[i][2] ] = [ n[0], n[1], n[2] ];
        }
        return norms;
    };

    /*Pretty much the same, except for the lack of normalization*/
    function faceVectors( verts, ind ) {
        var norms = new Array( verts.length );
        for ( var i = 0; i < ind.length; i++ ) {
            var a = vec3.fromValues(
                    verts[ ind[i][1] ][0] - verts[ ind[i][0] ][0],
                    verts[ ind[i][1] ][1] - verts[ ind[i][0] ][1],
                    verts[ ind[i][1] ][2] - verts[ ind[i][0] ][2]
            );
            var b = vec3.fromValues(
                    verts[ ind[i][2] ][0] - verts[ ind[i][0] ][0],
                    verts[ ind[i][2] ][1] - verts[ ind[i][0] ][1],
                    verts[ ind[i][2] ][2] - verts[ ind[i][0] ][2]
            );
            var n = vec3.cross( vec3.create(), a, b );

            norms[ ind[i][0] ] = [ n[0], n[1], n[2] ];
            norms[ ind[i][1] ] = [ n[0], n[1], n[2] ];
            norms[ ind[i][2] ] = [ n[0], n[1], n[2] ];
        }
        return norms;
    }

    /**
     * Calculates the per-vertex normal for each vertex in an array list. This operation
     * has O(N) time complexity.
     *
     * @param {Array} verts an array of triplets, where each triplet represents a coordinate
     * @param {Array} ind an array of triplets, where each triplet represents a triangle (three indices into vertex array)
     * @returns {Array} an array which matches a vertex array with each vertex given in the input array.
     */
    module.vertexNormals = function( verts, ind ) {
        /*construct adjacency list*/
        var adjacency = new Array( verts.length );	//store neighboring points
        for ( var i = 0; i < verts.length; i++ ) {
            adjacency[i] = [];
        }
        for ( var i = 0; i < ind.length; i++ ) {
            adjacency[ ind[i][0] ].push( ind[i][1], ind[i][2] );
            adjacency[ ind[i][1] ].push( ind[i][0], ind[i][2] );
            adjacency[ ind[i][2] ].push( ind[i][0], ind[i][1] );
        }

        var faceVecs = faceVectors( verts, ind );
        var norms = new Array( verts.length );

        for ( var i = 0; i < verts.length; i++ ) {
            var n = vec3.fromValues( 0.0, 0.0, 0.0 );
            for ( var j = 0; j < adjacency[i].length; j++ ) {
                vec3.add( n,
                    n,
                    vec3.fromValues(
                        faceVecs[ adjacency[i][j] ][0],
                        faceVecs[ adjacency[i][j] ][1],
                        faceVecs[ adjacency[i][j] ][2]
                    )
                );
            }
            vec3.normalize( n, n );
            norms[i] = new Array(3);
            norms[i][0] = n[0];
            norms[i][1] = n[1];
            norms[i][2] = n[2];
        }

        return norms;
    }

    /**
     * Calculates the surface variation, by calculating the Dirichlet Energy for
     * each polygon on the surface. The method has been developed based on the publication
     * "Comparing Dirichlet normal surface energy of tooth crowns,
     * a new technique of molar shape quantification for dietary inference,
     * with previous methods in isolation and in combination".
     *
     * @param {Array} verts unwrapped vertex array
     * @param {Array} vNorms	unwrapped vertex normal array
     * @returns {Array} Gives each vertex a color based on the surface variation of the polygon.
     */
    module.surfaceVariation = function( verts, vNorms ) {
        var largest = Number.NEGATIVE_INFINITY;	//the values should only be positive
        var smallest = Number.POSITIVE_INFINITY;
        var scalars = [];
        //the energy density at point p is calculated from
        // e(p) = tr(G^-1 * H), where G and H are matrices:
        // G = ( dot(u,u), dot(u,v), dot(uv), dot(vv)) and
        // H = ( dot(nu,nu), dot(nu, nv), dot(nu, nv), dot(nv, nv) )
        //this essentially measures how "spread out" the vertex normals are for
        //each triangle
        for ( var i = 0; i < verts.length; i += 9 ) {
            //build the matrix G
            var u = vec3.fromValues(
                    verts[i+3] - verts[i],
                    verts[i+4] - verts[i+1],
                    verts[i+5] - verts[i+2]
            );
            var v = vec3.fromValues(
                    verts[i+6] - verts[i],
                    verts[i+7] - verts[i+1],
                    verts[i+8] - verts[i+2]
            );
            var G = mat2.create();
            G[0] = vec3.dot( u, u );
            G[1] = vec3.dot( u, v );
            G[2] = vec3.dot( u, v );
            G[3] = vec3.dot( v, v );

            //build the matrix H
            var nu = vec3.fromValues(
                    vNorms[i+3] - vNorms[i],
                    vNorms[i+4] - vNorms[i+1],
                    vNorms[i+5] - vNorms[i+2]
            );
            var nv = vec3.fromValues(
                    vNorms[i+6] - vNorms[i],
                    vNorms[i+7] - vNorms[i+1],
                    vNorms[i+8] - vNorms[i+2]
            );
            var H = mat2.create();
            H[0] = vec3.dot( nu, nu );
            H[1] = vec3.dot( nu, nv );
            H[2] = vec3.dot( nu, nv );
            H[3] = vec3.dot( nv, nv );

            //calculate G^-1 * H:
            var res = mat2.create();
            mat2.invert( G, G );
            mat2.multiply( res, G, H );
            var trace = res[0] + res[3];
            trace = clampTrace( trace );

            //we store one scalar value per triangle
            scalars.push( trace );
            scalars.push( trace );
            scalars.push( trace );

            //store the largest encountered trace for normalization
            if ( trace > largest ) {
                largest = trace;
            } else if ( trace < smallest ) {
                smallest = trace;
            }
        }

        for ( var i = 0; i < scalars.length; i++ ) {
            scalars[i] /= largest;	//normalize!
            /*apply a curve to increase "contrast" of the lower curvature values.*/
            scalars[i] = 1 - Math.exp(2.99572315 - 15*scalars[i]) / 20.0;
        }

        return scalars;
    };

    /*A dirty hack: sometimes the curvature will be E+8 times larger than
     * the smallest value, meaning color variation are not visible. This clamps it so
     * that the range is more reasonable.*/
    function clampTrace( trace ) {
        if ( trace > 1000.0 ) {
            trace = 1000.0;
        }
        return trace;
    }

    /* norms: the unwrapped vertex normals
     * returns: an array of scalars for each vertex representing the orientation*/
    module.surfaceOrientation = function( norms ) {
        var regions = [];
        var n = 8;	//the number of orientations we are going to consider
        for ( var i = 0; i < norms.length; i += 3 ) {
            var or = vec2.normalize( vec2.create(), vec2.fromValues( norms[i], norms[i+1]) );
            var theta = angleRangeClamp( Math.atan2( or[1], or[0] ) );
            var region = Math.floor( theta / ( 2.0 * Math.PI / n) );	//find the region number in [1, n]

            region /= n-1;	//normalize!
            regions.push( region );
        }
        return regions;
    };

    function angleRangeClamp( angle ) {
        if ( angle > Math.PI * 2.0 ) {
            return angle - Math.PI * 2.0;
        } else if ( angle < 0.0 ) {
            return angle + Math.PI * 2.0;
        }
        return angle;
    }

    return module;
}( morphoviewer || {} ) );




/*
Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/


/* The mgl file (morphoviewer graphics library) defines the morphoviewer namespace
 * and contains utilities for interacting with WebGL, and complete shader programs.*/
var morphoviewer = ( function( module ) {
    //this is a namespace scope helper function for Program
    function getShaderFromDOM( gl, domId ) {
        var shaderScript, theSource, currentChild, shader;

        shaderScript = document.getElementById( domId );

        if ( !shaderScript ) {
            alert("getShaderFromDOM: no such shader: " + domId );
            return null;
        }

        theSource = "";
        currentChild = shaderScript.firstChild;

        while ( currentChild) {
            if ( currentChild.nodeType == currentChild.TEXT_NODE ) {
                theSource += currentChild.textContent;
            }
            currentChild = currentChild.nextSibling;
        }

        //create the shader object
        if ( shaderScript.type == "x-shader/x-fragment" ) {
            shader = getShaderFromString( gl, theSource, "fragment" );
        } else if ( shaderScript.type == "x-shader/x-vertex" ) {
            shader = getShaderFromString( gl, theSource, "vertex" );
        } else {
            //Unknown shader type
            alert( "getShaderFromDOM: unknown shader type, returning null." );
            return null;
        }
        return shader;
    }

    //helper function for Program
    function getShaderFromString( gl, sourceStr, type ) {
        var shader;
        //create the shader object
        if ( type == "fragment" ) {
            shader = gl.createShader( gl.FRAGMENT_SHADER );
        } else if ( type == "vertex" ) {
            shader = gl.createShader( gl.VERTEX_SHADER );
        } else {
            //Unknown shader type
            alert( "getShaderFromString: unknown shader type, returning null." );
            return null;
        }

        //pass the source into the shader object & compile
        gl.shaderSource( shader, sourceStr );

        gl.compileShader( shader );

        //check if compilation was succesful
        if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
            alert( "getShaderFromString: could not compile " + type + " shader: " +
                gl.getShaderInfoLog( shader ) );
            return null;
        }
        return shader;
    }

    /**
     * @class Creates a webGL shader program containing a vertex shader and fragment shader.
     * @name Program
     *
     * @param {Object} gl a valid webGL context
     * @param {String} vertexId the DOM id of the vertex shader code
     * @param {String} fragmentId the DOM id of the fragment shader code
     */
    module.Program = function( gl ) {
        this.gl = gl;
        this.object = null;

        //this.setUniforms
    };

    function getProgram( gl, vertObject, fragObject ) {
        var program = gl.createProgram();
        //link the objects to create shader program
        gl.attachShader( program, vertObject );
        gl.attachShader( program, fragObject );
        gl.linkProgram( program );
        //if linking failure, then log info:
        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
            console.log( "getProgram: unable to link the shader program " +
                gl.getProgramInfoLog( program ) );
        }
        return program;
    }

    module.Program.prototype.programFromDOM = function( vertexId, fragmentId ) {
        //first, get the shader objects
        var frag = getShaderFromDOM( this.gl, fragmentId );
        var vert = getShaderFromDOM( this.gl, vertexId );

        this.object = getProgram( this.gl, vert, frag );
    };

    module.Program.prototype.programFromString = function( vertexStr, fragmentStr ) {
        var vert = getShaderFromString( this.gl, vertexStr, "vertex" );
        var frag = getShaderFromString( this.gl, fragmentStr, "fragment" );

        this.object = getProgram( this.gl, vert, frag );
    };

    /**
     * Make WebGL use this program object.
     */
    module.Program.prototype.use = function() {
        this.gl.useProgram( this.object );
    };

    /**
     * Query whether this program object is currently in use by WebGL.
     *
     * @returns {Boolean} true, if in use, false otherwise.
     */
    module.Program.prototype.isInUse = function() {
        var currentProgram = 0;
        this.gl.getIntegerv( this.gl.GL_CURRENT_PROGRAM, currentdisProgram );
        if ( this.object == currentProgram ) {
            return true;
        }
        return false;
    };

    /**
     * Stops WebGL from using this program object by binding the current program slot to zero.
     */
    module.Program.prototype.stopUsing = function() {
        if ( this.isInUse() ) {
            this.gl.useProgram( null );
        }
    };

    /**
     * Query the location of an attribute.
     *
     * @param {String} attributeId the name of the attribute in the shader
     * @returns {Number} the location of the attribute
     */
    module.Program.prototype.attribute = function( attributeId ) {
        var attrib = this.gl.getAttribLocation( this.object, attributeId );
        if ( attrib == -1 ) {
            console.log( "Program.attribute: shader attribute " + attributeId + " not found." );
            return null;
        }

        return attrib;
    };

    /**
     * Query the location of a uniform in the shader
     *
     * @param {String} uniformId the name of the uniform in the shader
     * @returns {Number} the location of the uniform
     */
    module.Program.prototype.uniform = function( uniformId ) {
        var uniform = this.gl.getUniformLocation( this.object, uniformId );
        if ( uniform == -1 ) {
            console.log( "Program.uniform: shader uniform " + uniformId + " not found." );
            return null;
        }

        return uniform;
    };

    /**
     * Set a uniform to a specific value
     *
     * @param {String} uniformId
     * @param {Object} value the value can be a number, or gl-matrix type, such as vec3
     * @param {Object} opts the option syntax is { "type": "TYPE" }, where TYPE is float/vec3/vec4/mat4
     */
    module.Program.prototype.setUniform = function( uniformId, value, opts ) {
        switch ( opts.type ) {
            case "float": this.gl.uniform1f( this.uniform( uniformId ), value );
                break;
            case "vec3": this.gl.uniform3fv( this.uniform( uniformId ), value );
                break;
            case "vec4": this.gl.uniform4fv( this.uniform( uniformId), value );
                break;
            case "mat3": this.gl.uniformMatrix3fv( this.uniform( uniformId ), value );
                break;
            case "mat4": this.gl.uniformMatrix4fv( this.uniform( uniformId ), false, value );
                break;
            case "int": this.gl.uniform1i( this.uniform( uniformId ), value );
                break;
            default: console.log("Program.setUniform: unknown type " + opts["type"] );
        }
    };

    /**
     * @class This class is a wrapper for vertex buffer objects.
     *
     * @param {Object} gl a valid WebGL context
     */
    module.Mesh = function( gl ) {
        this.gl = gl;
        this.vbo = null;	//vertex buffer object must be {Object}
        this.numVertices = 0;
    };

    /**
     * Get the value of the vertex buffer object.
     *
     * @returns {Number} the vertex buffer object
     */
    module.Mesh.prototype.object = function() {
        return this.vbo;
    };

    /**
     * @class Build a mesh from an array of vertices and normals, and send to WebGL.
     * @name Mesh
     *
     * @param {Array} vertexArray
     * @param {Array} normalArray
     * @param {Array} colorArray (optional) array of vertex colors.
     */
    module.Mesh.prototype.meshFromArray = function( vertexArray, normalArray,
                                                    curvatureArray, orientationArray ) {
        this.vbo = this.gl.createBuffer();

        this.numVertices = vertexArray.length / 3.0;

        var barycentric = new Array( vertexArray.length );// vertexArray.length );
        for ( var i = 0; i < this.numVertices * 3; i += 9 ) {
            barycentric[i] = 1.0;
            barycentric[i+1] = 0.0;
            barycentric[i+2] = 0.0;
            barycentric[i+3] = 0.0;
            barycentric[i+4] = 1.0;
            barycentric[i+5] = 0.0;
            barycentric[i+6] = 0.0;
            barycentric[i+7] = 0.0;
            barycentric[i+8] = 1.0;
        }
        vertexArray = vertexArray.concat( barycentric)
        vertexArray = vertexArray.concat( normalArray );
        vertexArray = vertexArray.concat( curvatureArray );
        vertexArray = vertexArray.concat( orientationArray );
        /*if ( colorArray != undefined ) {
         vertexArray = vertexArray.concat( colorArray );
         }*/

        this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.vbo );
        //vertex data is stuck in here first
        //after the vertex data will come the normal vector data
        //will have to use vertexAttribPointer to set the correct offset for this vector
        //I want to have only on vertex buffer object
        this.gl.bufferData( this.gl.ARRAY_BUFFER,
            new Float32Array( vertexArray ),
            this.gl.STATIC_DRAW
        );
        this.gl.bindBuffer( this.gl.ARRAY_BUFFER, null );
    };

    /**
     * Query the number of distinct vertices that the contained mesh has.
     *
     * @return {Number} the number of vertices
     */
    module.Mesh.prototype.vertices = function() {
        return this.numVertices;
    };

    /**
     * Bind the contained vertex buffer object to the ARRAY_BUFFER target.
     */
    module.Mesh.prototype.bind = function() {
        this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.vbo );
    };

    /**
     * Bind the null object to the ARRAY_BUFFER target.
     */
    module.Mesh.prototype.unbind = function() {
        this.gl.bindBuffer( this.gl.ARRAY_BUFFER, null );
    };

    /**
     * @class Contains methods for manipulating the properties, position & orientation
     * of the viewport.
     * @name Camera
     *
     * @param {Number} fov the vertical field of view, in radians
     * @param {Number} ar the aspect ratio
     * @param {Number} near the distance of the near plane from the camera
     * @param {Number} far the distance of the far plane from the camera
     */
    module.Camera = function( fov, ar, near, far ) {
        //position
        this.position = vec3.fromValues( 0.0, 0.0, 2.0 );
        this.targetPosition = vec3.fromValues( 0.0, 0.0, 2.0 );

        this.targetRadius = 2.0;
        this.radius = 10.0;

        this.center	= vec3.fromValues( 0.0, 0.0, 0.0 );
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );

        this.polar = Math.PI / 2.0;
        this.azimuth = 0.0;

        this.viewTransform = mat4.create();
        this.orientation = quat.fromValues( 0.0, 0.0, 0.0, 0.0 );

        this.sensitivity = 0.1 * this.radius;

        //good default values are fov: 67 degrees, aspectRatio: 1.333, near: 0.01, far: 100
        this.verticalFOV = fov;
        this.aspectRatio = ar;
        this.nearPlane = near;
        this.farPlane = far;

        this.viewPerspective = false;
        this.zoomFactor = 1.0;	//for orthographic projection dolly zoom
        this.targetZoomFactor = 1.0;
    };

    module.Camera.prototype.matrix = function() {
        var m = mat4.create();
        mat4.multiply( m, this.perspective(), this.view() );
        return m;
    };

    module.Camera.prototype.viewAsOrtho = function() {
        this.viewPerspective = false;
    };

    module.Camera.prototype.viewAsPerspective = function() {
        this.viewPerspective = true;
    };

    /**
     * @returns {mat4} the perspective matrix of the camera
     */
    module.Camera.prototype.perspective = function() {
        var m;
        if ( this.viewPerspective ) {
            m = mat4.perspective(
                mat4.create(),
                this.verticalFOV,
                this.aspectRatio,
                this.nearPlane,
                this.farPlane
            );
        } else {
            m = mat4.ortho(
                mat4.create(),
                //the box needs to have the same size as the canvas!
                //the 0.01 factor should not be changed, or it breaks the
                //calculation of optimal zoom factor for model
                -lerp( this.nearPlane, this.farPlane,
                        this.aspectRatio * 0.01 * this.zoomFactor ),
                lerp( this.nearPlane, this.farPlane,
                        this.aspectRatio * 0.01 * this.zoomFactor ),
                -lerp( this.nearPlane, this.farPlane, 0.01 * this.zoomFactor ),
                lerp( this.nearPlane, this.farPlane, 0.01 * this.zoomFactor ),
                this.nearPlane,
                this.farPlane
            );
        }
        return m;
    };

    /**
     * @returns {mat4} the view matrix (combined rotation and translation matrix) of the camera
     */
    module.Camera.prototype.view = function() {
        return this.viewTransform;
    };

    module.Camera.prototype.getPosition = function() {
        var pos = vec3.fromValues(
            -this.position[0],
            -this.position[1],
            -this.position[2]
        );
        return pos;
    };

    /**
     * @param {Number} fov the vertical field of view, in radians
     */
    module.Camera.prototype.setFOV = function( fov ) {
        if ( fov < 0.0 ) {
            throw "Camera.setFOV: negative vertical field of view";
        }
        this.verticalFOV = fov;
    };

    module.Camera.prototype.setAspectRatio = function( ar ) {
        if ( ar < 0.0 ) {
            throw "Camera.setAspectRatio: negative aspect ratio";
        }
        this.aspectRatio = ar;
    };

    module.Camera.prototype.setNearPlane = function( near ) {
        if ( near > this.farPlane ) {
            throw "Camera.setNearPlane: near plane is farther than the far plane";
        }
        this.nearPlane = near;
    };

    module.Camera.prototype.setFarPlane = function( far ) {
        if ( far < this.nearPlane ) {
            throw "Camera.setFarPlane: far plane is nearer than the near plane";
        }
        this.farPlane = far;
    };

    /**
     * Pan the focal point around the camera's local XY plane
     */
    module.Camera.prototype.pan = function( movex, movey ) {
        deltaX = vec3.scale( vec3.create(), this.right(), this.sensitivity * movex );
        vec3.add( this.targetCenter, this.targetCenter, deltaX );

        deltaY = vec3.scale( vec3.create(), this.up(), this.sensitivity * movey );
        vec3.add( this.targetCenter, this.targetCenter, deltaY );
    };

    /**
     * Dolly along the Z axis of the camera's local transform
     */
    module.Camera.prototype.dolly = function( movez ) {
        this.targetRadius += this.sensitivity * movez;
        if ( this.targetRadius < 0 ) {
            this.targetRadius = 0.001;
        }
    };

    /**
     * Orbit about the focal point
     */
    module.Camera.prototype.orbit = function( movex, movey ) {
        this.polar -= movey;
        this.polar = clamp( this.polar, 0.01, Math.PI );
        this.azimuth -= movex;
    };

    function clamp( val, min, max ){
        if ( val < min ) {
            val = min;
        } else if ( val > max ) {
            val = max;
        }
        return val;
    }

    /*Parameters are intended to be
     * a {Number}
     * b {Number}
     * t {Number} in [0,1]*/
    function lerp( a, b, t ) {
        if ( t > 1 ) t = 1;
        return a + t * ( b - a );
    }

    /*Returns {mat3} rotation matrix corresponding to the rotation
     * theta about the axis u.*/
    //CONTRIBUTE THIS TO GLMATRIX!
    function mat3FromAxisAngle( u, theta ) {
        var r = mat3.create();
        r[0] = Math.cos(theta) + u[0]*u[0] * (1.0 - Math.cos(theta) );
        r[1] = u[0]*u[1] * (1.0 - Math.cos(theta)) - u[2]*Math.sin(theta);
        r[2] = u[0]*u[2] * (1.0 - Math.cos(theta)) + u[1]*Math.sin(theta);
        r[3] = u[1]*u[0] * (1.0 - Math.cos(theta)) + u[2]*Math.sin(theta);
        r[4] = Math.cos(theta) + u[1]*u[1]*(1.0 - Math.cos(theta));
        r[5] = u[1]*u[2] * (1.0 - Math.cos(theta)) - u[0]*Math.sin(theta);
        r[6] = u[2]*u[0] * (1.0 - Math.cos(theta)) - u[1]*Math.sin(theta);
        r[7] = u[2]*u[1] * (1.0 - Math.cos(theta)) + u[0]*Math.sin(theta);
        r[8] = Math.cos(theta) + u[2]*u[2] * (1.0 - Math.cos(theta));
        return r;
    }

    module.Camera.prototype.update = function( dt ) {
        /*targetZoomFactor defines how wide the orthographic projection is, as there
         * is no depth.
         * this relation was arrived at by trial and error
         * when switching between perspective and ortho, the object does not change size*/
        this.targetZoomFactor = 0.07 * this.targetRadius;

        //update values
        this.zoomFactor = lerp( this.zoomFactor, this.targetZoomFactor, dt * 20 );
        this.radius = lerp( this.radius, this.targetRadius, dt * 20 );
        vec3.lerp( this.center, this.center, this.targetCenter, dt * 20 );
        this.sensitivity = 0.1 * this.radius;

        var offset = vec3.fromValues(
            Math.sin( this.polar ) * Math.sin( this.azimuth ),
            Math.cos( this.polar ),
            Math.sin( this.polar ) * Math.cos( this.azimuth )
        );

        this.targetPosition = vec3.add(
            vec3.create(),
            this.center,
            vec3.scale(
                vec3.create(),
                offset,
                this.radius
            )
        );
        vec3.lerp( this.position, this.position, this.targetPosition, dt * 20 );

        var right = vec3.cross( vec3.create(), offset, vec3.fromValues( 0.0, 1.0, 0.0));
        vec3.normalize( right, right );
        var up = vec3.cross( vec3.create(), right, offset );	//get the new up vector
        mat4.lookAt(
            this.viewTransform,
            this.position,
            this.center,
            up
        );
        quat.fromMat3(
            this.orientation,
            mat3.fromMat4( mat3.create(), this.viewTransform )
        );
    };

    /**
     * Sets the camera to a position where the target object is centered and in full view.
     */
    module.Camera.prototype.setBestPositionForModel = function( aabb ) {
        //this.targetCenter = vec3.fromValues( aabb.center.x, aabb.center.y, aabb.center.z );
        var halfy = Math.max( Math.abs(aabb.max.y), Math.abs(aabb.min.y) );
        var halfx = Math.max( Math.abs(aabb.max.x), Math.abs(aabb.min.x) );
        var widthExtent = Math.max( halfy, halfx );
        //calculate for perspective
        this.targetRadius = 1.1 * widthExtent / Math.tan( 0.5 * this.verticalFOV );
    };

    /**
     * @returns {vec3} the normalized vector pointing forward in the local coordinate system
     */
    module.Camera.prototype.forward = function() {
        var rot = mat4.create();
        mat4.fromQuat( rot, this.orientation );
        mat4.invert( rot, rot );
        var forward = vec4.fromValues( 0.0, 0.0, -1.0, 1.0 );
        vec4.transformMat4( forward, forward, rot );
        return vec3.fromValues( forward[0], forward[1], forward[2] );
    };

    module.Camera.prototype.right = function() {
        var rot = mat4.fromQuat( mat4.create(), this.orientation );
        mat4.invert( rot, rot );
        var right = vec4.fromValues( 1.0, 0.0, 0.0, 1.0 );
        vec4.transformMat4( right, right, rot );
        return vec3.fromValues( right[0], right[1], right[2] );
    };

    module.Camera.prototype.up = function() {
        var rot = mat4.create();
        mat4.fromQuat( rot, this.orientation );
        mat4.invert( rot, rot );
        var up = vec4.fromValues( 0.0, 1.0, 0.0, 1.0 );
        vec4.transformMat4( up, up, rot );
        return vec3.fromValues( up[0], up[1], up[2] );
    };

    module.Camera.prototype.positionLeft = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = Math.PI / 2.0;
        this.azimuth = Math.PI / 2.0;
    };

    module.Camera.prototype.positionRight = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = Math.PI / 2.0;
        this.azimuth = 3.0 * Math.PI / 2.0;
    };

    module.Camera.prototype.positionTop = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = 0.001;
        this.azimuth = 0.0;
    };

    module.Camera.prototype.positionBottom = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = Math.PI;
        this.azimuth = 0.0;
    };

    module.Camera.prototype.positionFront = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = Math.PI / 2.0;
        this.azimuth = 0.0;
    };

    module.Camera.prototype.positionBack = function() {
        this.targetCenter = vec3.fromValues( 0.0, 0.0, 0.0 );
        this.polar = Math.PI / 2.0;
        this.azimuth = Math.PI;
    };

    //shaders
    module.directional =  {
        materialShininess: 40.0,
        materialSurfaceColor: vec3.fromValues( 0.6, 0.6, 0.6 ),
        materialSpecularColor: vec3.fromValues( 0.9, 0.9, 0.9 ),
        lightDirection: vec3.fromValues( 1.0, 0.0, -1.0 ),	//this needs to be normalized
        lightHalfVector: vec3.fromValues( 0.0, 0.0, -1.0 ),	//this needs to be normalized
        lightIntensities: vec3.fromValues( 1.0, 1.0, 0.9 ),
        lightAmbientCoefficient: 0.1,
        camera: mat4.create(),
        model: mat4.create(),
        cameraPosition: vec3.fromValues( 0.0, 0.0, -1.0 ),
        /**
         * Enable vertex attributes arrays for this shader. Remember to bind the
         * correct shader program before using this function.
         *
         * @param {Object} gl a valid webGL context
         * @param {Program} program the shader program that we want to initialize
         */
        enableAttributes: function( gl, program ) {
            gl.enableVertexAttribArray( program.attribute( "vert" ) );
            gl.enableVertexAttribArray( program.attribute( "normal" ) );
        },

        /**
         * With the correct mesh bound, set the vertex attribute pointer for this shader.
         *
         * @param {Object} gl
         * @param {Program} program
         * @param {Number} numVertices the number of vertices that the mesh contains
         */
        setAttributes: function( gl, program, numVertices ) {
            gl.vertexAttribPointer( program.attribute( "vert" ),
                3, gl.FLOAT, false, 0, 0 );
            //before normal, there is barycentric
            gl.vertexAttribPointer( program.attribute( "normal" ),
                3, gl.FLOAT, false, 0, 12 * 2 * numVertices );
        },

        /**
         * Set the uniforms for the shader.
         *
         * @param {Program} program
         */
        setUniforms: function( program ) {
            program.setUniform( "material.shininess",
                this.materialShininess,
                { type: "float" } );
            program.setUniform( "material.surfaceColor",
                this.materialSurfaceColor,
                { type: "vec3" } );
            program.setUniform( "material.specularColor",
                this.materialSpecularColor,
                { type: "vec3" } );
            var lightdir = vec3.create();
            vec3.normalize( lightdir, this.lightDirection );
            program.setUniform( "light.direction",
                lightdir,
                { type: "vec3" } );
            var halfvec = vec3.create();
            vec3.normalize( halfvec, this.lightHalfVector );
            program.setUniform( "light.halfVector",
                halfvec,
                { type: "vec3" } );
            program.setUniform( "light.intensities",
                this.lightIntensities,
                { type: "vec3" } );
            program.setUniform( "light.ambientCoefficient",
                this.lightAmbientCoefficient,
                { type: "float" } );

            var normal = mat4.create();	//the normal matrix
            mat4.invert( normal, this.model );
            mat4.transpose( normal, normal );

            program.setUniform( "camera", this.camera, { type: "mat4" } );
            program.setUniform( "normalMatrix", normal, { type: "mat4" } );
            program.setUniform( "model", this.model, { type: "mat4" } );
            program.setUniform( "cameraPosition", this.cameraPosition, {type:"vec3"} );
        },
        vertex:
            "uniform mat4 model;\n" +
            "uniform mat4 normalMatrix;\n" +
            "uniform mat4 camera;\n" +
            "uniform mediump vec3 cameraPosition;\n" +

            "attribute vec3 vert;\n" +
            "attribute vec3 normal;\n" +

            "varying mediump vec3 surfToCamera;\n" +
            "varying mediump vec3 fragPos;\n" +
            "varying mediump vec3 fragNormal;\n"+

            "void main( void ) {\n" +
            "	//just pass this value through for interpolation\n" +
            "	fragNormal = vec3( normalMatrix * vec4( normal, 0.0 ) );\n" +

            "	fragPos = vec3( model * vec4( vert, 1.0 ) );\n" +

            "	surfToCamera = normalize( vec3( cameraPosition - fragPos ) );\n" +

            "	gl_Position = camera * model * vec4( vert, 1.0 );\n" +
            "}",
        fragment:
            "struct Material {\n" +
            "	mediump float shininess;\n" +
            "	mediump vec3 surfaceColor;\n" +
            "	mediump vec3 specularColor;\n" +
            "};\n" +

            "struct DirectionalLight {\n" +
            "	mediump vec3 direction;	//this needs to be normalized\n" +
            "	mediump vec3 halfVector;\n" +
            "	mediump vec3 intensities;\n" +
            "	mediump float ambientCoefficient;\n" +
            "};\n" +

            "uniform Material material;\n" +
            "uniform DirectionalLight light;\n" +

            "varying mediump vec3 surfToCamera;\n" +
            "varying mediump vec3 fragPos;\n" +
            "varying mediump vec3 fragNormal;\n" +

            "void main( void ) {\n" +
            "	//ambient\n" +
            "	mediump vec3 ambient = light.ambientCoefficient * material.surfaceColor * light.intensities;\n" +

            "	//diffuse\n" +
            "	mediump float diffuseCoefficient =  max( 0.0, dot( fragNormal, light.direction ) );\n" +
            "	mediump vec3 diffuse = diffuseCoefficient * material.surfaceColor * light.intensities;\n" +

            "	//specular\n" +
            "	mediump float specularCoefficient = 0.0;\n" +
            "	if ( diffuseCoefficient > 0.0 ) {\n" +
            "		mediump vec3 reflection = normalize( reflect( light.halfVector, fragNormal ) );\n" +
            "		specularCoefficient = pow( max( 0.0, dot( surfToCamera, reflection ) ), material.shininess );\n" +
            "	}\n" +
            "	mediump vec3 specular = specularCoefficient * material.specularColor;\n" +

            "	mediump vec3 linearColor = ambient + diffuse + specular;\n" +

            "	mediump vec3 gamma = vec3( 1.0 / 2.2 );\n" +

            "	gl_FragColor = vec4( pow( linearColor, gamma ), 1.0 );\n" +
            "}"
    };

    module.color = {
        camera: mat4.create(),
        model: mat4.create(),
        colorMode: 1,
        enableAttributes: function( gl, program ) {
            gl.enableVertexAttribArray( program.attribute( "vert" ) );
            gl.enableVertexAttribArray( program.attribute( "curvature" ) );
            gl.enableVertexAttribArray( program.attribute( "orientation" ) );
        },
        setAttributes: function( gl, program, numVertices ) {
            gl.vertexAttribPointer( program.attribute( "vert" ),
                3, gl.FLOAT, false, 0, 0 );
            //between color and vert there is norm and barycentric
            gl.vertexAttribPointer( program.attribute( "curvature" ),
                1, gl.FLOAT, false, 0, 36 * numVertices );
            gl.vertexAttribPointer( program.attribute( "orientation"),
                1, gl.FLOAT, false, 0, 40 * numVertices );
        },
        setUniforms: function( program ) {
            program.setUniform( "camera", this.camera, { type: "mat4" } );
            program.setUniform( "model", this.model, { type: "mat4" } );
            program.setUniform( "colorMode", this.colorMode, { type: "int" } );
        },
        vertex:
            "precision mediump float;\n"+

            "attribute vec3 vert;\n" +
            "attribute float curvature;\n" +
            "attribute float orientation;\n" +

            "uniform mat4 model;\n" +
            "uniform mat4 camera;\n" +

            "uniform int colorMode;\n" +

            "varying vec4 fragColor;\n" +

            "vec4 yellowToRed( float scalar );\n" +
            "vec4 longRainbow( float scalar );\n" +
            "vec4 shortRainbow( float scalar );\n" +

            "void main() {\n" +
            "	if ( colorMode == 1 ) {	//dirichlet normal energy\n" +
            "		fragColor = yellowToRed( curvature );\n" +
            "	} else if ( colorMode == 2 ) {	//orientation map\n" +
            "		fragColor = longRainbow( orientation );\n" +
            "	}\n" +
            "	gl_Position = camera * model * vec4( vert, 1.0 );\n" +
            "}\n" +

            "vec4 yellowToRed( float scalar ) {\n"+
                "vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n"+
                "color.r = 1.0;\n" +
                "color.g = 1.0 - scalar;\n" +
                "return color;\n" +
            "}\n" +

            "vec4 longRainbow( float scalar ) {\n" +
                "vec3 color = vec3( 0.0, 0.0, 0.0 );\n" +
                "if ( scalar >= 0.0 && scalar < 0.1666 ) {\n" +
                "	color.g = scalar * 6.0;\n" +
                "	color.b = 1.0;\n" +
                "} else if ( scalar >= 0.1666 && scalar < 0.3333 ) {\n" +
                "	color.g = 1.0;\n" +
                "	color.b = 1.0 - 6.0 * (scalar - 0.1666);\n" +
                "} else if ( scalar >= 0.3333 && scalar < 0.5000 ) {\n" +
                "	color.r = 6.0 * (scalar - 0.3333);\n" +
                "	color.g = 1.0;\n" +
                "} else if ( scalar >= 0.5000 && scalar < 0.6666 ) {\n" +
                "	color.r = 1.0;\n" +
                "	color.g = 1.0 - 6.0 * (scalar - 0.5000);\n" +
                "} else if ( scalar >= 0.6666 && scalar < 0.8333 ) {\n" +
                "   color.b = 6.0*(scalar - 0.6666);\n"+
                "   color.r = 1.0;\n"+
                "} else if ( scalar >= 0.8333 && scalar <= 1.0 ) {\n" +
                "   color.b = 1.0;\n"+
                "   color.r = 1.0 - 6.0 * (scalar - 0.8333);\n"+
                "}\n"+
                "return vec4( color, 1.0 );\n" +
            "}\n" +

            "vec4 shortRainbow( float scalar ) {	//scalar must be normalized!\n" +
                "vec3 color = vec3( 0.0, 0.0, 0.0 );\n" +
                "if ( scalar >= 0.0 && scalar < 0.25 ) {\n" +
                "	color.g = scalar * 4.0;	//green varies linearly between [0,1]\n" +
                "	color.b = 1.0;			//blue is maxed out\n" +
                "} else if ( scalar >= 0.25 && scalar < 0.35 ) {\n" +
                "	color.g = 1.0;			//green is maxed out\n" +
                "	color.b = 1.0 - 10.0 * ( scalar - 0.25 );	//blue varies between [1,0]\n" +
                "} else if ( scalar >= 0.35 && scalar < 0.75 ) {\n" +
                "	color.r = ( scalar - 0.35 ) * 2.5;	//red varies between [0,1]\n" +
                "	color.g = 1.0;					//green is maxed out\n" +
                "} else if ( scalar >= 0.75 && scalar <= 1.0 ) {\n" +
                "	color.r = 1.0;	//red is maxed out\n" +
                "	color.g = 1.0 - 4.0 * ( scalar - 0.75 );	//green varies between [1,0]\n" +
                "}\n" +
                "return vec4( color, 1.0 );\n" +
            "}\n",
        fragment:
            "precision mediump float;\n" +
            "varying vec4 fragColor;\n" +

            "void main() {\n" +
            "	gl_FragColor = fragColor;\n" +
            "}\n"
    };

    module.wireframe = {
        camera: mat4.create(),
        model: mat4.create(),
        surfaceColor: vec3.fromValues( 0.6, 0.6, 0.6 ),

        enableAttributes: function( gl, program ) {
            gl.enableVertexAttribArray( program.attribute( "vert" ) );
            gl.enableVertexAttribArray( program.attribute( "barycentric" ) );
        },

        setAttributes: function( gl, program, numVertices ) {
            gl.vertexAttribPointer( program.attribute( "vert" ),
                3, gl.FLOAT, false, 0, 0 );
            gl.vertexAttribPointer( program.attribute( "barycentric" ),
                3, gl.FLOAT, false, 0, 12 * numVertices );
        },

        setUniforms: function( program ) {
            program.setUniform( "camera", this.camera, { type: "mat4" } );
            program.setUniform( "model", this.model, { type: "mat4" } );
            program.setUniform( "surfaceColor", this.surfaceColor, {type:"vec3"} );
        },
        vertex:
            "attribute vec3 vert;\n" +
            "attribute vec3 barycentric;\n"+

            "uniform mat4 camera;\n" +
            "uniform mat4 model;\n" +

            "varying mediump vec3 barycentricPos;\n" +

            "void main( void ) {\n" +
            "	barycentricPos = barycentric;\n" +
            "	gl_Position = camera * model * vec4( vert, 1.0 );\n" +
            "}",
        fragment:
            "uniform mediump vec3 surfaceColor;\n" +
            "varying mediump vec3 barycentricPos;\n" +

            "void main( void ) {\n" +
            "	if ( any( lessThan( barycentricPos, vec3( 0.02 ) ) ) ) {\n" +
            "		gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n" +
            "	} else {\n" +
            "		gl_FragColor = vec4( surfaceColor, 1.0 );\n" +
            "	}\n" +
            "}"
    };

    module.hemisphere = {
        camera: mat4.create(),
        model: mat4.create(),
        normalMatrix: mat4.create(),
        skyColor: vec3.fromValues( 0.830, 0.819, 0.819 ),
        groundColor: vec3.fromValues( 0.181, 0.161, 0.095 ),
        polar: 0,
        azimuth: 0,

        enableAttributes: function( gl, program ) {
            gl.enableVertexAttribArray( program.attribute( "vert" ) );
            gl.enableVertexAttribArray( program.attribute( "norm" ) );
        },

        setAttributes: function( gl, program, numVertices ) {
            gl.vertexAttribPointer( program.attribute( "vert" ),
                3, gl.FLOAT, false, 0, 0 );
            //before normal, there is barycentric
            gl.vertexAttribPointer( program.attribute( "norm" ),
                3, gl.FLOAT, false, 0, 12 * 2 * numVertices );
        },

        setUniforms: function( program ) {
            // calculate the light's position
            var lightVector = vec3.fromValues(
                Math.sin( this.polar ) * Math.sin( this.azimuth ),
                Math.cos( this.polar ),
                Math.sin( this.polar ) * Math.cos( this.azimuth )
            );
            program.setUniform( "lightPosition",
                lightVector,
                { type: "vec3"} );
            program.setUniform( "skyColor",
                this.skyColor, { type: "vec3" } );
            program.setUniform( "groundColor",
                this.groundColor, { type: "vec3" } );

            var normal = mat4.create();	//the normal matrix
            mat4.invert( normal, this.model );
            mat4.transpose( normal, normal );

            program.setUniform( "normalMatrix", normal, { type: "mat4" } );
            program.setUniform( "camera", this.camera, { type: "mat4" } );
            program.setUniform( "model", this.model, { type: "mat4" } );
        },
        vertex:
            "precision mediump float;\n" +

            "attribute vec3 vert;\n" +
            "attribute vec3 norm;\n" +

            "uniform mat4 camera;\n" +
            "uniform mat4 model;\n" +
            "uniform mat4 normalMatrix;\n" +

            "uniform vec3 lightPosition;\n" +
            "uniform vec3 skyColor;\n" +
            "uniform vec3 groundColor;\n" +

            "varying vec3 fragColor;\n" +

            "void main() {\n" +
            "	vec3 fragNormal = vec3( normalMatrix * vec4( norm, 0.0 ) );\n" +
            "	vec3 position = vec3( model * vec4( vert, 1.0 ) );\n" +
            "	vec3 lightVector = normalize( lightPosition - normalize( position ) );\n" +

            "	float theta = dot( fragNormal, lightVector );\n" +
            "	float a = theta * 0.5 + 0.5;\n" +
            "	fragColor = mix( groundColor, skyColor, a );\n" +
            "	gl_Position = camera * model * vec4( vert, 1.0 );\n" +
            "}",

        fragment:
            "precision mediump float;\n" +

            "varying vec3 fragColor;\n" +
            "void main() {\n" +
            "	gl_FragColor = vec4(fragColor, 1.0 );\n" +
            "}"
    };

    return module;
}( morphoviewer || {} ) );



/*
Copyright (c) 2014 Johann Muszynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/

/**
 * @namespace The morphoviewer namespace contains functions for viewing and manipulating
 * morphological data from voxel data files, or point cloud data files.
 */

var morphoviewer = ( function( tools ) {

    //public interface goes here
    var module = {};

    var gl;

    var fps = 40.0;
    var camera;
    var modelView = mat4.create();	//identity matrix, models centered at (0, 0, 0)
    var mesh;

    var renderFunctor = function() {};	//do nothing initially

    var wireframeProgram;	//the wireframe shader program
    var illuminationProgram;//the illumination shader program
    var colorProgram;		//the surface curvature shader program
    var currentProgram;

    var timer;

    var mouse = { prevX: 0, prevY: 0,
        dx: 0, dy: 0 };

    /**
     * Initialize the morphoviewer.
     *
     * @param {String} canvasId the DOM id of the HTML5 canvas. If the parameter is not
     * supplied, the "glcanvas" id will be searched for.
     */
    module.initialize = function( canvasId ) {

        if ( canvasId == undefined ) {
            cid = "glcanvas";
        } else {
            cid = canvasId;
        }
        //declared globally for later use
        canvas = document.getElementById( cid );

        //Event handlers for input
        canvas.onmousedown = onMouseDown;
        canvas.onmouseup = onMouseUp;
        canvas.oncontextmenu = function( e ) { e.preventDefault(); };

        //add a mousewheel event listener to the canvas
        if ( canvas.addEventListener ) {
            //IE9, Chrome, Safari, Opera
            canvas.addEventListener( "mousewheel", onMouseWheel, false );
            //Firefox
            canvas.addEventListener( "DOMMouseScroll", onMouseWheel );
        } else {
            //IE6/7/8
            canvas.addEventListener( "onmousewheel", onMouseWheel );
        }

        gl = initWebGL( canvas );

        //continue only if WebGL is available and working
        if ( gl ) {
            gl.clearColor( 0.10, 0.16, 0.16, 1.0 );
            gl.enable( gl.DEPTH_TEST );
            gl.depthFunc( gl.LEQUAL );
            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

            setInterval( drawScene, 1000.0 / fps );
        } else {
            alert( "morphoviewer.initialize: Unable to initialize WebGL. Your browser may not support it." );
        }

        timer = new Date();

        //the morphoviewer has only one camera
        var aspectRatio = canvas.clientWidth / canvas.clientHeight;
        camera = new tools.Camera( Math.PI * 67.0 / 180.0, aspectRatio, 0.01, 1000.0 );

        initShaders();
    };

    function initWebGL( canvas ) {
        var context = null;
        try {
            context = canvas.getContext( "webgl" ) || canvas.getContext( "experimental-webgl" );
        } catch( e ) {
            //
        }

        return context;
    }

    function initShaders() {
        wireframeProgram = new tools.Program( gl );
        wireframeProgram.programFromString( tools.wireframe.vertex, tools.wireframe.fragment );

        colorProgram = new tools.Program( gl );
        colorProgram.programFromString( tools.color.vertex, tools.color.fragment );

        illuminationProgram = new tools.Program( gl );
        illuminationProgram.programFromString( tools.directional.vertex, tools.directional.fragment );

        hemisphereProgram = new tools.Program( gl );
        hemisphereProgram.programFromString( tools.hemisphere.vertex, tools.hemisphere.fragment );
    }

    function onMouseWheel( e ) {
        var event = window.event || e;
        //prevent from scrolling the document
        event.preventDefault();
        event.stopImmediatePropagation();
        //handle dolly zoom
        var delta = event.detail ? event.detail * (-120) : event.wheelDelta;
        camera.dolly( delta * -0.0025 );
    }

    function onMouseDown( event ) {
        if ( !event.which && event.button ) {
            if ( event.button & 1 ) {		//Left
                event.which = 1;
            } else if ( event.button & 4 ) {//Middle
                event.which = 2;
            } else if ( event.button & 2 ) {//Right
                event.which = 3;
            }
        }
        /*Update mouse coordinates so that we don't create
         * a huge delta in the opposite direction*/
        mouse.prevX = event.pageX;
        mouse.prevY = event.pageY;
        switch ( event.which ) {
            case 1:
                canvas.onmousemove = function( e ) {
                    onMouseMove( e );
                    camera.orbit( mouse.dx * 0.004, mouse.dy * 0.004 );
                };
                break;
            case 3:
                canvas.onmousemove = function( e ) {
                    onMouseMove( e );
                    camera.pan( mouse.dx * -0.01, mouse.dy * 0.01 );
                };
                break;
        }
    }

    function onMouseUp( event ) {
        canvas.onmousemove = function( e ) {return false;};
    }

    function onMouseMove( event ) {
        var x = event.pageX;
        var y = event.pageY;
        mouse.dx = x - mouse.prevX;
        mouse.dy = y - mouse.prevY;
        mouse.prevX = x;
        mouse.prevY = y;
    }

    function drawScene() {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        var endTime = new Date();
        var deltaTime = endTime - timer;
        deltaTime /= 1000.0;

        camera.update( deltaTime );

        renderFunctor();

        timer = new Date();
    }

    /**
     * View a 3d file. The file can be a csv point cloud, or a .OBJ mesh file.
     *
     * @param {String} file The file URL
     * @param {String} type Can be either "obj" for .OBJ mesh file, or "point cloud" for csv point cloud.
     */
    module.viewData = function( file, type ) {
        if ( type == "obj" ) {
            mesh = new tools.Mesh( gl );

            var onload = function( model ) {
                tools.centerPointCloud( model.vertices.v );
                var verts = tools.unwrapVectorArray( model.vertices.v, model.vertices.i );
                var norms;
                if ( model.normals.v.length == 0 ) {
                    norms = tools.vertexNormals( model.vertices.v, model.vertices.i );
                    norms = tools.unwrapVectorArray( norms, model.vertices.i );
                } else {
                    norms = tools.unwrapVectorArray( model.normals.v, model.normals.i );
                }

                var curvature = tools.surfaceVariation( verts, norms );
                var orientation = tools.surfaceOrientation( norms );

                mesh.meshFromArray( verts, norms, curvature, orientation );
                module.viewIlluminated();
                var aabb = tools.getAabb( model.vertices.v );
                camera.setBestPositionForModel( aabb );
            };

            tools.vertexArrayFromOBJ( file, onload );

        } else if ( type == "point cloud" ) {
            mesh = new tools.Mesh( gl );
            var onload = function( points ) {
                tools.centerPointCloud( points );
                var tris = tools.triangulate( points );

                var verts = tools.unwrapVectorArray( points, tris );
                var norms = tools.vertexNormals( points, tris );
                norms = tools.unwrapVectorArray( norms, tris );
                var curvature = tools.surfaceVariation( verts, norms );
                var orientation = tools.surfaceOrientation( norms );

                //mesh = new tools.Mesh( gl );
                mesh.meshFromArray( verts, norms, curvature, orientation );
                module.viewIlluminated();
                var aabb = tools.getAabb( points );
                camera.setBestPositionForModel( aabb );
            };

            tools.vertexArrayFromPointCloud( file, onload );

        }  else if ( type == "morphobuffer" ) {
            mesh = new tools.Mesh(gl);
            var onload = function (model) {
                //vertices have to unwrapped
                var verts = tools.unwrapVectorArray(model.vertices.v, model.vertices.i);
                //normals are per-vertex and have to be unwrapped
                var norms = tools.unwrapVectorArray(model.normals, model.vertices.i);
                //orientation values are per-vertex and have to be unwrapped
                var orientation = tools.unwrapArray(model.orientation, model.vertices.i);
                //curvature is per-face and is already unwrapped by the parsing process
                mesh.meshFromArray(verts, norms, model.curvature, orientation);
                module.viewHemispherical();
                var aabb = tools.getAabb(model.vertices.v);
                camera.setBestPositionForModel(aabb);
            };
            tools.vertexArrayFromMorphobuffer(file, onload);

        } else if ( type == "ply" ) {
            parsers.load( file, 'ply', function( model ) { alert("Inside the onload of ply loading."); }  );


        } else {
            throw "morphoviewer.viewData: unrecognized 3d file type";
        }
    };

    /**
     * View the object as a wire frame model.
     * */
    module.viewWireframe = function() {
        currentProgram = wireframeProgram;
        currentProgram.use();
        mesh.bind();
        tools.wireframe.enableAttributes( gl, currentProgram );
        tools.wireframe.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.wireframe.camera = camera.matrix();
            tools.wireframe.model = modelView;
            tools.wireframe.setUniforms( currentProgram );
            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        };
    };

    /**
     * Color the surface of the object according to the discreet orientation of each polygon.
     * */
    module.viewSurfaceOrientation = function() {
        if ( currentProgram.object != colorProgram.object ) {
            currentProgram = colorProgram;
            currentProgram.use();
            setupColorShader();
        }
        tools.color.colorMode = 2;
    };

    /**
     * Color the surface of the object according to its local surface curvature.
     * */
    module.viewSurfaceCurvature = function() {
        if ( currentProgram.object != colorProgram.object ) {
            currentProgram = colorProgram;
            currentProgram.use();
            setupColorShader();
        }
        tools.color.colorMode = 1;
    };

    function setupColorShader() {
        mesh.bind();
        tools.color.enableAttributes( gl, currentProgram );
        tools.color.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.color.camera = camera.matrix();
            tools.color.model = modelView;
            tools.color.setUniforms( currentProgram );
            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    }
    /**
     * Set the directional light shader as the active shader.
     * */
    module.viewIlluminated = function() {
        currentProgram = illuminationProgram;
        currentProgram.use();

        mesh.bind();
        tools.directional.enableAttributes( gl, currentProgram );
        tools.directional.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();
            tools.directional.camera = camera.matrix();
            tools.directional.model = modelView;
            tools.directional.cameraPosition = camera.getPosition();
            tools.directional.setUniforms( currentProgram );

            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    };

    /**
     * View the model under a hemispherical light source.
     * */
    module.viewHemispherical = function() {
        currentProgram = hemisphereProgram;
        currentProgram.use();

        mesh.bind();
        tools.hemisphere.enableAttributes( gl, currentProgram );
        tools.hemisphere.setAttributes( gl, currentProgram, mesh.vertices() );
        mesh.unbind();

        renderFunctor = function() {
            mesh.bind();

            tools.hemisphere.camera = camera.matrix();
            tools.hemisphere.model = modelView;
            tools.hemisphere.setUniforms( currentProgram );

            gl.drawArrays( gl.TRIANGLES, 0, mesh.vertices() );
            mesh.unbind();
        }
    };

    /**
     * View with orthographic projection.
     */
    module.viewOrtho = function() {
        camera.viewAsOrtho();
    };


    /**
     * View with perspective projection.
     */
    module.viewPerspective = function() {
        camera.viewAsPerspective();
    };

    module.viewLeft = function() {
        camera.positionLeft();
    };

    module.viewRight = function() {
        camera.positionRight();
    };

    module.viewTop = function() {
        camera.positionTop();
    };

    module.viewBottom = function() {
        camera.positionBottom();
    };

    module.viewFront = function() {
        camera.positionFront();
    };

    module.viewBack = function() {
        camera.positionBack();
    };

    module.color = {
        black: vec3.fromValues(0.0, 0.0, 0.0),
        white: vec3.fromValues(1.0, 1.0, 1.0),
        lightgray: vec3.fromValues(0.91, 0.91, 0.91),
        lightgrey: vec3.fromValues(0.91, 0.91, 0.91),
        darkgray: vec3.fromValues(0.41, 0.41, 0.41),
        darkgrey: vec3.fromValues(0.41, 0.41, 0.41)
    };

    /**
     * Set the background color of the viewport.
     *
     * @param {vec3} color A vector containing the RGB color.
     * */
    module.setBackgroundColor = function( color ) {
        gl.clearColor(
            color[0],
            color[1],
            color[2],
            1.0
        );
    };

    module.setLightPolarAngle = function( theta ) {
        tools.hemisphere.polar = theta;
    };

    module.setLightAzimuthalAngle = function( phi ) {
        tools.hemisphere.azimuth = phi;
    };

    return module;
}( morphoviewer ));



